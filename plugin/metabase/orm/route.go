/*
 * Copyright (c) 2019, 2025, firmer.tech and/or its affiliates. All rights reserved.
 * Firmer Corporation PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 */

// Code generated by mesh; DO NOT EDIT.

package orm

import (
	"context"
	"database/sql"
	"time"

	"git.firmer.tech/firmer/mesh/client/golang/cause"
	"git.firmer.tech/firmer/mesh/client/golang/orm/dao"
	"git.firmer.tech/firmer/mesh/client/golang/orm/planner/specs"
	"git.firmer.tech/firmer/mesh/client/golang/types"
)

// route 路由表
type Route struct {
	Name           string    `index:"1" json:"name" xml:"name" yaml:"name" comment:"名称"`
	Listen         string    `index:"2" json:"listen" xml:"listen" yaml:"listen" comment:"监听"`
	Matcher        string    `index:"3" json:"matcher" xml:"matcher" yaml:"matcher" comment:"正则"`
	Backend        string    `index:"4" json:"backend" xml:"backend" yaml:"backend" comment:"服务"`
	Priority       int64     `index:"5" json:"priority" xml:"priority" yaml:"priority" comment:"优先级"`
	PassHostHeader int64     `index:"6" json:"pass_host_header" xml:"pass_host_header" yaml:"pass_host_header" comment:"是否透传头"`
	CreateAt       time.Time `index:"7" json:"create_at" xml:"create_at" yaml:"create_at" comment:"创建时间"`
	UpdateAt       time.Time `index:"8" json:"update_at" xml:"update_at" yaml:"update_at" comment:"更新时间"`
	CreateBy       string    `index:"9" json:"create_by" xml:"create_by" yaml:"create_by" comment:"创建人"`
	UpdateBy       string    `index:"10" json:"update_by" xml:"update_by" yaml:"update_by" comment:"更新人"`
}
type RouteDao interface {

	// Index
	// SELECT * FROM `route` ORDER BY `name` ASC LIMIT '?.index', '?.limit'
	Index(ctx context.Context, index int64, limit int64) (*types.Page[*Route], error)

	// All
	// SELECT * FROM `route`
	All(ctx context.Context) ([]*Route, error)

	// InsertRoute
	// INSERT INTO `route` (`name`, `listen`, `matcher`, `backend`, `priority`, `pass_host_header`, `create_at`, `update_at`, `create_by`, `update_by`) VALUES ('?.name', '?.listen', '?.matcher', '?.backend', '?.priority', '?.passHostHeader', '?.createAt', '?.updateAt', '?.createBy', '?.updateBy')
	InsertRoute(ctx context.Context, it *Route) (int64, error)

	// UpdateRouteByName
	// UPDATE `route` SET `listen` = '?.listen', `matcher` = '?.matcher', `backend` = '?.backend', `priority` = '?.priority', `pass_host_header` = '?.passHostHeader', `create_at` = '?.createAt', `update_at` = '?.updateAt', `create_by` = '?.createBy', `update_by` = '?.updateBy' WHERE `name` = '?.name'
	UpdateRouteByName(ctx context.Context, it *Route) (int64, error)

	// DeleteRouteByName
	// DELETE FROM `route` WHERE `name` = '?.name'
	DeleteRouteByName(ctx context.Context, name string) (int64, error)

	// SelectRouteByName
	// SELECT * FROM `route` WHERE `name` = '?.name'
	SelectRouteByName(ctx context.Context, name string) (*Route, error)
}

type meshRouteDiv struct {
}

func (that *meshRouteDiv) Index(ctx context.Context, index int64, limit int64) (*types.Page[*Route], error) {
	return dao.Page[Route](ctx, &specs.Vars{
		Expr: "SELECT * FROM `route` ORDER BY `name` ASC LIMIT '?.index', '?.limit'",
		Args: map[string]any{
			"index": index,
			"limit": limit,
		},
		Flags: int64(types.PageResultSet),
	})
}

func (that *meshRouteDiv) All(ctx context.Context) ([]*Route, error) {
	rs, err := dao.Query[Route](ctx, &specs.Vars{
		Expr: "SELECT * FROM `route`",
		Args: map[string]any{},
	})
	if nil != err {
		return nil, cause.Error(err)
	}
	return rs, nil
}

func (that *meshRouteDiv) InsertRoute(ctx context.Context, it *Route) (int64, error) {
	return dao.Exec(ctx, &specs.Vars{
		Expr: "INSERT INTO `route` (`name`, `listen`, `matcher`, `backend`, `priority`, `pass_host_header`, `create_at`, `update_at`, `create_by`, `update_by`) VALUES ('?.name', '?.listen', '?.matcher', '?.backend', '?.priority', '?.passHostHeader', '?.createAt', '?.updateAt', '?.createBy', '?.updateBy')",
		Args: map[string]any{
			"name":           it.Name,
			"listen":         it.Listen,
			"matcher":        it.Matcher,
			"backend":        it.Backend,
			"priority":       it.Priority,
			"passHostHeader": it.PassHostHeader,
			"createAt":       it.CreateAt,
			"updateAt":       it.UpdateAt,
			"createBy":       it.CreateBy,
			"updateBy":       it.UpdateBy,
		},
	})
}

func (that *meshRouteDiv) UpdateRouteByName(ctx context.Context, it *Route) (int64, error) {
	return dao.Exec(ctx, &specs.Vars{
		Expr: "UPDATE `route` SET `listen` = '?.listen', `matcher` = '?.matcher', `backend` = '?.backend', `priority` = '?.priority', `pass_host_header` = '?.passHostHeader', `create_at` = '?.createAt', `update_at` = '?.updateAt', `create_by` = '?.createBy', `update_by` = '?.updateBy' WHERE `name` = '?.name'",
		Args: map[string]any{
			"listen":         it.Listen,
			"matcher":        it.Matcher,
			"backend":        it.Backend,
			"priority":       it.Priority,
			"passHostHeader": it.PassHostHeader,
			"createAt":       it.CreateAt,
			"updateAt":       it.UpdateAt,
			"createBy":       it.CreateBy,
			"updateBy":       it.UpdateBy,
			"name":           it.Name,
		},
	})
}

func (that *meshRouteDiv) DeleteRouteByName(ctx context.Context, name string) (int64, error) {
	return dao.Exec(ctx, &specs.Vars{
		Expr: "DELETE FROM `route` WHERE `name` = '?.name'",
		Args: map[string]any{
			"name": name,
		},
	})
}

func (that *meshRouteDiv) SelectRouteByName(ctx context.Context, name string) (*Route, error) {
	rs, err := dao.Query[Route](ctx, &specs.Vars{
		Expr: "SELECT * FROM `route` WHERE `name` = '?.name'",
		Args: map[string]any{
			"name": name,
		},
	})
	if nil != err {
		return nil, cause.Error(err)
	}
	if len(rs) < 1 {
		return nil, cause.Error(sql.ErrNoRows)
	}
	return rs[0], nil
}
