/*
 * Copyright (c) 2019, 2025, firmer.tech and/or its affiliates. All rights reserved.
 * Firmer Corporation PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 *
 *
 */

// Code generated by mesh; DO NOT EDIT.

package orm

import (
	"context"
	"database/sql"
	"time"

	"git.firmer.tech/firmer/mesh/client/golang/cause"
	"git.firmer.tech/firmer/mesh/client/golang/orm/dao"
	"git.firmer.tech/firmer/mesh/client/golang/orm/planner/specs"
)

// meshSeq 序列号表
type MeshSeq struct {
	Kind     string    `index:"1" json:"kind" xml:"kind" yaml:"kind" comment:"序列号类型"`
	Min      int64     `index:"2" json:"min" xml:"min" yaml:"min" comment:"当前范围最小值"`
	Max      int64     `index:"3" json:"max" xml:"max" yaml:"max" comment:"当前范围最大值"`
	Size     int64     `index:"4" json:"size" xml:"size" yaml:"size" comment:"每次取号段大小"`
	Length   int64     `index:"5" json:"length" xml:"length" yaml:"length" comment:"序列号长度不足补零"`
	Status   int64     `index:"6" json:"status" xml:"status" yaml:"status" comment:"状态"`
	Version  int64     `index:"7" json:"version" xml:"version" yaml:"version" comment:"乐观锁版本"`
	CreateAt time.Time `index:"8" json:"create_at" xml:"create_at" yaml:"create_at" comment:"创建时间"`
	UpdateAt time.Time `index:"9" json:"update_at" xml:"update_at" yaml:"update_at" comment:"更新时间"`
}
type SequenceDao interface {

	// SetMin
	// UPDATE `mesh_seq` SET `min` = '?.min', `version` = `version` + 1 WHERE `kind` = '?.kind' AND `version` = '?.version'
	SetMin(ctx context.Context, min int64, kind string, version int64) (int64, error)

	// SelectByKindForUpdate
	// SELECT * FROM `mesh_seq` WHERE `kind` = '?.kind' FOR UPDATE
	SelectByKindForUpdate(ctx context.Context, kind string) (*MeshSeq, error)

	// InsertMeshSeq
	// INSERT INTO `mesh_seq` (`kind`, `min`, `max`, `size`, `length`, `status`, `version`, `create_at`, `update_at`) VALUES ('?.kind', '?.min', '?.max', '?.size', '?.length', '?.status', '?.version', '?.createAt', '?.updateAt')
	InsertMeshSeq(ctx context.Context, it *MeshSeq) (int64, error)

	// UpdateMeshSeqByKind
	// UPDATE `mesh_seq` SET `min` = '?.min', `max` = '?.max', `size` = '?.size', `length` = '?.length', `status` = '?.status', `version` = '?.version', `create_at` = '?.createAt', `update_at` = '?.updateAt' WHERE `kind` = '?.kind'
	UpdateMeshSeqByKind(ctx context.Context, it *MeshSeq) (int64, error)

	// DeleteMeshSeqByKind
	// DELETE FROM `mesh_seq` WHERE `kind` = '?.kind'
	DeleteMeshSeqByKind(ctx context.Context, kind string) (int64, error)

	// SelectMeshSeqByKind
	// SELECT * FROM `mesh_seq` WHERE `kind` = '?.kind'
	SelectMeshSeqByKind(ctx context.Context, kind string) (*MeshSeq, error)
}

type meshSequenceDiv struct {
}

func (that *meshSequenceDiv) SetMin(ctx context.Context, min int64, kind string, version int64) (int64, error) {
	return dao.Exec(ctx, &specs.Vars{
		Expr: "UPDATE `mesh_seq` SET `min` = '?.min', `version` = `version` + 1 WHERE `kind` = '?.kind' AND `version` = '?.version'",
		Args: map[string]any{
			"min":     min,
			"kind":    kind,
			"version": version,
		},
	})
}

func (that *meshSequenceDiv) SelectByKindForUpdate(ctx context.Context, kind string) (*MeshSeq, error) {
	rs, err := dao.Query[MeshSeq](ctx, &specs.Vars{
		Expr: "SELECT * FROM `mesh_seq` WHERE `kind` = '?.kind' FOR UPDATE",
		Args: map[string]any{
			"kind": kind,
		},
	})
	if nil != err {
		return nil, cause.Error(err)
	}
	if len(rs) < 1 {
		return nil, cause.Error(sql.ErrNoRows)
	}
	return rs[0], nil
}

func (that *meshSequenceDiv) InsertMeshSeq(ctx context.Context, it *MeshSeq) (int64, error) {
	return dao.Exec(ctx, &specs.Vars{
		Expr: "INSERT INTO `mesh_seq` (`kind`, `min`, `max`, `size`, `length`, `status`, `version`, `create_at`, `update_at`) VALUES ('?.kind', '?.min', '?.max', '?.size', '?.length', '?.status', '?.version', '?.createAt', '?.updateAt')",
		Args: map[string]any{
			"kind":     it.Kind,
			"min":      it.Min,
			"max":      it.Max,
			"size":     it.Size,
			"length":   it.Length,
			"status":   it.Status,
			"version":  it.Version,
			"createAt": it.CreateAt,
			"updateAt": it.UpdateAt,
		},
	})
}

func (that *meshSequenceDiv) UpdateMeshSeqByKind(ctx context.Context, it *MeshSeq) (int64, error) {
	return dao.Exec(ctx, &specs.Vars{
		Expr: "UPDATE `mesh_seq` SET `min` = '?.min', `max` = '?.max', `size` = '?.size', `length` = '?.length', `status` = '?.status', `version` = '?.version', `create_at` = '?.createAt', `update_at` = '?.updateAt' WHERE `kind` = '?.kind'",
		Args: map[string]any{
			"min":      it.Min,
			"max":      it.Max,
			"size":     it.Size,
			"length":   it.Length,
			"status":   it.Status,
			"version":  it.Version,
			"createAt": it.CreateAt,
			"updateAt": it.UpdateAt,
			"kind":     it.Kind,
		},
	})
}

func (that *meshSequenceDiv) DeleteMeshSeqByKind(ctx context.Context, kind string) (int64, error) {
	return dao.Exec(ctx, &specs.Vars{
		Expr: "DELETE FROM `mesh_seq` WHERE `kind` = '?.kind'",
		Args: map[string]any{
			"kind": kind,
		},
	})
}

func (that *meshSequenceDiv) SelectMeshSeqByKind(ctx context.Context, kind string) (*MeshSeq, error) {
	rs, err := dao.Query[MeshSeq](ctx, &specs.Vars{
		Expr: "SELECT * FROM `mesh_seq` WHERE `kind` = '?.kind'",
		Args: map[string]any{
			"kind": kind,
		},
	})
	if nil != err {
		return nil, cause.Error(err)
	}
	if len(rs) < 1 {
		return nil, cause.Error(sql.ErrNoRows)
	}
	return rs[0], nil
}
