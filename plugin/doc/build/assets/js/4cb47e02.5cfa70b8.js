"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[8596],{5568:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"reference/routing-configuration/kubernetes/crd/udp/ingressrouteudp","title":"IngressRouteUDP","description":"Understand the routing configuration for the Kubernetes IngressRouteUDP & Mesh CRD","source":"@site/docs/reference/routing-configuration/kubernetes/crd/udp/ingressrouteudp.md","sourceDirName":"reference/routing-configuration/kubernetes/crd/udp","slug":"/reference/routing-configuration/kubernetes/crd/udp/ingressrouteudp","permalink":"/doc/docs/reference/routing-configuration/kubernetes/crd/udp/ingressrouteudp","draft":false,"unlisted":false,"editUrl":"https://github.com/opendatav/mesh/tree/main/packages/create-docusaurus/templates/shared/docs/reference/routing-configuration/kubernetes/crd/udp/ingressrouteudp.md","tags":[],"version":"current","frontMatter":{"title":"IngressRouteUDP","description":"Understand the routing configuration for the Kubernetes IngressRouteUDP & Mesh CRD"},"sidebar":"tutorialSidebar","previous":{"title":"TLSStore","permalink":"/doc/docs/reference/routing-configuration/kubernetes/crd/tcp/tlsstore"},"next":{"title":"Mesh Kubernetes Gateway","permalink":"/doc/docs/reference/routing-configuration/kubernetes/gateway-api"}}');var r=t(4848),i=t(8453);const o={title:"IngressRouteUDP",description:"Understand the routing configuration for the Kubernetes IngressRouteUDP & Mesh CRD"},a=void 0,c={},d=[{value:"Configuration Example",id:"configuration-example",level:2},{value:"Configuration Options",id:"configuration-options",level:2},{value:"ExternalName Service",id:"externalname-service",level:3},{value:"NativeLB",id:"nativelb",level:3}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"IngressRouteUDP"})," is the CRD implementation of a ",(0,r.jsx)(n.a,{href:"/doc/docs/reference/routing-configuration/udp/router/rules-priority",children:"Mesh UDP router"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Before creating ",(0,r.jsx)(n.code,{children:"IngressRouteUDP"})," objects, you need to apply the ",(0,r.jsx)(n.a,{href:"https://doc.Mesh.io/Mesh/reference/dynamic-configuration/kubernetes-crd/#definitions",children:"Mesh Kubernetes CRDs"})," to your Kubernetes cluster."]}),"\n",(0,r.jsxs)(n.p,{children:["This registers the ",(0,r.jsx)(n.code,{children:"IngressRouteUDP"})," kind and other mesh-specific resources."]}),"\n",(0,r.jsx)(n.h2,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRouteUDP"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRouteUDP\nmetadata:\n  name: ingressrouteudpfoo\n  namespace: apps\nspec:\n  entryPoints:\n    - fooudp  # The entry point where Mesh listens for incoming traffic.\n  routes:\n  - services:\n    - name: foo # The name of the Kubernetes Service to route to.\n      port: 8080\n      weight: 10\n      nativeLB: true # Enables native load balancing between pods.\n"})}),"\n",(0,r.jsx)(n.h2,{id:"configuration-options",children:"Configuration Options"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Field"}),(0,r.jsx)(n.th,{children:"Description"}),(0,r.jsx)(n.th,{children:"Default"}),(0,r.jsx)(n.th,{children:"Required"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"entryPoints"})}),(0,r.jsx)(n.td,{children:"List of entrypoints names."}),(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{children:"No"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"routes"})}),(0,r.jsx)(n.td,{children:"List of routes."}),(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{children:"Yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"routes[n].services"})}),(0,r.jsxs)(n.td,{children:["List of ",(0,r.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," definitions. See ",(0,r.jsx)(n.a,{href:"#externalname-service",children:"here"})," for ",(0,r.jsx)(n.code,{children:"ExternalName Service"})," setup."]}),(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{children:"No"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"services[n].name"})}),(0,r.jsxs)(n.td,{children:["Defines the name of a ",(0,r.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"}),"."]}),(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{children:"Yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"routes[n].services[n].port"})}),(0,r.jsxs)(n.td,{children:["Defines the port of a ",(0,r.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"}),". This can be a reference to a named port."]}),(0,r.jsx)(n.td,{}),(0,r.jsx)(n.td,{children:"Yes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"routes[n].services[n].weight"})}),(0,r.jsx)(n.td,{children:"Defines the weight to apply to the server load balancing."}),(0,r.jsx)(n.td,{children:"1"}),(0,r.jsx)(n.td,{children:"No"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"routes[n].services[n].nativeLB"})}),(0,r.jsx)(n.td,{children:"Controls, when creating the load-balancer, whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP."}),(0,r.jsx)(n.td,{children:"false"}),(0,r.jsx)(n.td,{children:"No"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"routes[n].services[n].nodePortLB"})}),(0,r.jsxs)(n.td,{children:["Controls, when creating the load-balancer, whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort. It allows services to be reachable when Mesh runs externally from the Kubernetes cluster but within the same network of the nodes. See ",(0,r.jsx)(n.a,{href:"#nativelb",children:"here"})," for more information."]}),(0,r.jsx)(n.td,{children:"false"}),(0,r.jsx)(n.td,{children:"No"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"externalname-service",children:"ExternalName Service"}),"\n",(0,r.jsxs)(n.p,{children:["Mesh backends creation needs a port to be set, however Kubernetes ",(0,r.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/#externalname",children:"ExternalName Service"})," could be defined without any port. Accordingly, Mesh supports defining a port in two ways:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["only on ",(0,r.jsx)(n.code,{children:"IngressRouteUDP"})," service"]}),"\n",(0,r.jsxs)(n.li,{children:["on both sides, you'll be warned if the ports don't match, and the ",(0,r.jsx)(n.code,{children:"IngressRouteUDP"})," service port is used"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Thus, in case of two sides port definition, Mesh expects a match between ports."}),"\n",(0,r.jsx)(n.p,{children:'=== "Ports defined on Resource"'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRouteUDP"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRouteUDP\nmetadata:\n  name: test.route\n  namespace: apps\n\nspec:\n  entryPoints:\n    - foo\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: external-svc\n      port: 80\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'tab="Service ExternalName"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: apps\n\nspec:\n  externalName: external.domain\n  type: ExternalName\n"})}),"\n",(0,r.jsx)(n.p,{children:'=== "Port defined on the Service"'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRouteUDP"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRouteUDP\nmetadata:\n  name: test.route\n  namespace: apps\n\nspec:\n  entryPoints:\n    - foo\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: external-svc\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'tab="Service ExternalName"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: apps\n\nspec:\n  externalName: external.domain\n  type: ExternalName\n  ports:\n    - port: 80\n"})}),"\n",(0,r.jsx)(n.p,{children:'=== "Port defined on both sides"'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRouteUDP"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRouteUDP\nmetadata:\n  name: test.route\n  namespace: apps\n\nspec:\n  entryPoints:\n    - foo\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: external-svc\n      port: 80\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'tab="Service ExternalName"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: apps\n\nspec:\n  externalName: external.domain\n  type: ExternalName\n  ports:\n    - port: 80\n"})}),"\n",(0,r.jsx)(n.h3,{id:"nativelb",children:"NativeLB"}),"\n",(0,r.jsxs)(n.p,{children:["To avoid creating the server load-balancer with the pods IPs and use Kubernetes Service ",(0,r.jsx)(n.code,{children:"clusterIP"})," directly, one should set the ",(0,r.jsx)(n.code,{children:"NativeLB"})," option to true. By default, ",(0,r.jsx)(n.code,{children:"NativeLB"})," is false."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRouteUDP"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRouteUDP\nmetadata:\n  name: test.route\n  namespace: default\nspec:\n  entryPoints:\n    - foo\nroutes:\n- services:\n  - name: svc\n    port: 80\n    # Here, nativeLB instructs to build the servers load balancer with the Kubernetes Service clusterIP only.\n    nativeLB: true\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",metastring:'tab="Service"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: svc\n  namespace: default\nspec:\n  type: ClusterIP\n  ...\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);