"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[2899],{8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var i=n(6540);const r={},s=i.createContext(r);function o(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:t},e.children)}},9177:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"getting-started/faq","title":"Mesh Getting Started FAQ","description":"Check out our FAQ page for answers to commonly asked questions on getting started with Mesh Proxy. Read the technical documentation.","source":"@site/docs/getting-started/faq.md","sourceDirName":"getting-started","slug":"/getting-started/faq","permalink":"/doc/docs/getting-started/faq","draft":false,"unlisted":false,"editUrl":"https://github.com/opendatav/mesh/tree/main/packages/create-docusaurus/templates/shared/docs/getting-started/faq.md","tags":[],"version":"current","frontMatter":{"title":"Mesh Getting Started FAQ","description":"Check out our FAQ page for answers to commonly asked questions on getting started with Mesh Proxy. Read the technical documentation."},"sidebar":"tutorialSidebar","previous":{"title":"Mesh Configuration Documentation","permalink":"/doc/docs/getting-started/configuration-overview"},"next":{"title":"Mesh Installation Documentation","permalink":"/doc/docs/getting-started/install-mesh"}}');var r=n(4848),s=n(8453);const o={title:"Mesh Getting Started FAQ",description:"Check out our FAQ page for answers to commonly asked questions on getting started with Mesh Proxy. Read the technical documentation."},a="FAQ",c={},d=[{value:"Why is Mesh Answering <code>XXX</code> HTTP Response Status Code?",id:"why-is-mesh-answering-xxx-http-response-status-code",level:2},{value:"<code>404 Not found</code>",id:"404-not-found",level:3},{value:"<code>502 Bad Gateway</code>",id:"502-bad-gateway",level:3},{value:"<code>503 Service Unavailable</code>",id:"503-service-unavailable",level:3},{value:"<code>XXX</code> Instead of <code>404</code>",id:"xxx-instead-of-404",level:3},{value:"Why Is My TLS Certificate Not Reloaded When Its Contents Change?",id:"why-is-my-tls-certificate-not-reloaded-when-its-contents-change",level:2},{value:"What Are the Forwarded Headers When Proxying HTTP Requests?",id:"what-are-the-forwarded-headers-when-proxying-http-requests",level:2},{value:"How Mesh is Storing and Serving TLS Certificates?",id:"how-mesh-is-storing-and-serving-tls-certificates",level:2},{value:"Storing TLS Certificates",id:"storing-tls-certificates",level:3},{value:"Examples:",id:"examples",level:4},{value:"Serving TLS Certificates",id:"serving-tls-certificates",level:3},{value:"Examples:",id:"examples-1",level:4},{value:"Caching TLS Certificates",id:"caching-tls-certificates",level:3},{value:"What does the &quot;field not found&quot; error mean?",id:"what-does-the-field-not-found-error-mean",level:2},{value:"Why are some resources (routers, middlewares, services...) not created/applied?",id:"why-are-some-resources-routers-middlewares-services-not-createdapplied",level:2},{value:"Why does Let&#39;s Encrypt wildcard certificate renewal/generation with DNS challenge fail?",id:"why-does-lets-encrypt-wildcard-certificate-renewalgeneration-with-dns-challenge-fail",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"faq",children:"FAQ"})}),"\n",(0,r.jsxs)(t.h2,{id:"why-is-mesh-answering-xxx-http-response-status-code",children:["Why is Mesh Answering ",(0,r.jsx)(t.code,{children:"XXX"})," HTTP Response Status Code?"]}),"\n",(0,r.jsx)(t.p,{children:"Mesh is a dynamic reverse proxy,\nand while the documentation often demonstrates configuration options through file examples,\nthe core feature of Mesh is its dynamic configurability,\ndirectly reacting to changes from providers over time."}),"\n",(0,r.jsxs)(t.p,{children:["Notably, a part of the configuration is ",(0,r.jsx)(t.a,{href:"../configuration-overview/#the-static-configuration",children:"static"}),",\nand can be provided by a file on startup, whereas various providers,\nsuch as the file provider,\ncontribute dynamically all along the Mesh instance lifetime to its ",(0,r.jsx)(t.a,{href:"../configuration-overview/#the-dynamic-configuration",children:"dynamic configuration"})," changes."]}),"\n",(0,r.jsx)(t.p,{children:"In addition, the configuration englobes concepts such as the EntryPoint which can be seen as a listener on the Transport Layer (TCP),\nas apposed to the Router which is more about the Presentation (TLS) and Application layers (HTTP).\nAnd there can be as many routers as one wishes for a given EntryPoint."}),"\n",(0,r.jsx)(t.p,{children:"In other words, for a given Entrypoint,\nat any given time the traffic seen is not bound to be just about one protocol.\nIt could be HTTP, or otherwise. Over TLS, or not.\nNot to mention that dynamic configuration changes potentially make that kind of traffic vary over time."}),"\n",(0,r.jsxs)(t.p,{children:["Therefore, in this dynamic context,\nthe static configuration of an ",(0,r.jsx)(t.code,{children:"entryPoint"})," does not give any hint whatsoever about how the traffic going through that ",(0,r.jsx)(t.code,{children:"entryPoint"})," is going to be routed.\nOr whether it's even going to be routed at all,\nthat is whether there is a Router matching the kind of traffic going through it."]}),"\n",(0,r.jsx)(t.h3,{id:"404-not-found",children:(0,r.jsx)(t.code,{children:"404 Not found"})}),"\n",(0,r.jsxs)(t.p,{children:["Mesh returns a ",(0,r.jsx)(t.code,{children:"404"})," response code in the following situations:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"A request reaching an EntryPoint that has no Routers"}),"\n",(0,r.jsx)(t.li,{children:"An HTTP request reaching an EntryPoint that has no HTTP Router"}),"\n",(0,r.jsx)(t.li,{children:"An HTTPS request reaching an EntryPoint that has no HTTPS Router"}),"\n",(0,r.jsx)(t.li,{children:"A request reaching an EntryPoint that has HTTP/HTTPS Routers that cannot be matched"}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["From Mesh's point of view,\nevery time a request cannot be matched with a router the correct response code is a ",(0,r.jsx)(t.code,{children:"404 Not found"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["In this situation, the response code is not a ",(0,r.jsx)(t.code,{children:"503 Service Unavailable"}),"\nbecause Mesh is not able to confirm that the lack of a matching router for a request is only temporary.\nMesh's routing configuration is dynamic and aggregated from different providers,\nhence it's not possible to assume at any moment that a specific route should be handled or not."]}),"\n",(0,r.jsx)(t.p,{children:'??? info "This behavior is consistent with rfc7231"'}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-txt",children:"The server is currently unable to handle the request due to a\ntemporary overloading or maintenance of the server. The implication\nis that this is a temporary condition which will be alleviated after\nsome delay. If known, the length of the delay MAY be indicated in a\nRetry-After header. If no Retry-After is given, the client SHOULD\nhandle the response as it would for a 500 response.\n\n    Note: The existence of the 503 status code does not imply that a\n    server must use it when becoming overloaded. Some servers may wish\n    to simply refuse the connection.\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Extract from ",(0,r.jsx)(t.a,{href:"https://datatracker.ietf.org/doc/html/rfc7231#section-6.6.4",children:"rfc7231#section-6.6.4"}),"."]}),"\n",(0,r.jsx)(t.h3,{id:"502-bad-gateway",children:(0,r.jsx)(t.code,{children:"502 Bad Gateway"})}),"\n",(0,r.jsxs)(t.p,{children:["Mesh returns a ",(0,r.jsx)(t.code,{children:"502"})," response code when an error happens while contacting the upstream service."]}),"\n",(0,r.jsx)(t.h3,{id:"503-service-unavailable",children:(0,r.jsx)(t.code,{children:"503 Service Unavailable"})}),"\n",(0,r.jsxs)(t.p,{children:["Mesh returns a ",(0,r.jsx)(t.code,{children:"503"})," response code when a Router has been matched,\nbut there are no servers ready to handle the request."]}),"\n",(0,r.jsx)(t.p,{children:"This situation is encountered when a service has been explicitly configured without servers,\nor when a service has healthcheck enabled and all servers are unhealthy."}),"\n",(0,r.jsxs)(t.h3,{id:"xxx-instead-of-404",children:[(0,r.jsx)(t.code,{children:"XXX"})," Instead of ",(0,r.jsx)(t.code,{children:"404"})]}),"\n",(0,r.jsxs)(t.p,{children:["Sometimes, the ",(0,r.jsx)(t.code,{children:"404"})," response code doesn't play well with other parties or services (such as CDNs)."]}),"\n",(0,r.jsxs)(t.p,{children:["In these situations, you may want Mesh to always reply with a ",(0,r.jsx)(t.code,{children:"503"})," response code,\ninstead of a ",(0,r.jsx)(t.code,{children:"404"})," response code."]}),"\n",(0,r.jsx)(t.p,{children:"To achieve this behavior, a catchall router,\nwith the lowest possible priority and routing to a service without servers,\ncan handle all the requests when no other router has been matched."}),"\n",(0,r.jsxs)(t.p,{children:["The example below is a file provider only version (",(0,r.jsx)(t.code,{children:"yaml"}),") of what this configuration could look like:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="Static configuration"',children:"# Mesh.yml\n\nentryPoints:\n  web:\n    address: :80\n\nproviders:\n  file:\n    filename: dynamic.yaml\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="Dynamic configuration"',children:'# dynamic.yaml\n\nhttp:\n  routers:\n    catchall:\n      # attached only to web entryPoint\n      entryPoints:\n        - "web"\n      # catchall rule\n      rule: "PathPrefix(`/`)"\n      service: unavailable\n      # lowest possible priority\n      # evaluated when no other router is matched\n      priority: 1\n\n  services:\n    # Service that will always answer a 503 Service Unavailable response\n    unavailable:\n      loadBalancer:\n        servers: {}\n'})}),"\n",(0,r.jsxs)(t.p,{children:['!!! info "Dedicated service"\nIf there is a need for a response code other than a ',(0,r.jsx)(t.code,{children:"503"})," and/or a custom message,\nthe principle of the above example above (a catchall router) still stands,\nbut the ",(0,r.jsx)(t.code,{children:"unavailable"})," service should be adapted to fit such a need."]}),"\n",(0,r.jsx)(t.h2,{id:"why-is-my-tls-certificate-not-reloaded-when-its-contents-change",children:"Why Is My TLS Certificate Not Reloaded When Its Contents Change?"}),"\n",(0,r.jsxs)(t.p,{children:["With the file provider,\na configuration update is only triggered when one of the ",(0,r.jsx)(t.a,{href:"/doc/docs/providers/file#provider-configuration",children:"watched"})," configuration files is modified."]}),"\n",(0,r.jsxs)(t.p,{children:["Which is why, when a certificate is defined by path,\nand the actual contents of this certificate change,\na configuration update is ",(0,r.jsx)(t.em,{children:"not"})," triggered."]}),"\n",(0,r.jsxs)(t.p,{children:["To take into account the new certificate contents, the update of the dynamic configuration must be forced.\nOne way to achieve that, is to trigger a file notification,\nfor example, by using the ",(0,r.jsx)(t.code,{children:"touch"})," command on the configuration file."]}),"\n",(0,r.jsx)(t.h2,{id:"what-are-the-forwarded-headers-when-proxying-http-requests",children:"What Are the Forwarded Headers When Proxying HTTP Requests?"}),"\n",(0,r.jsx)(t.p,{children:"By default, the following headers are automatically added when proxying requests:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Property"}),(0,r.jsx)(t.th,{children:"HTTP Header"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Client's IP"}),(0,r.jsx)(t.td,{children:"X-Forwarded-For, X-Real-Ip"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Host"}),(0,r.jsx)(t.td,{children:"X-Forwarded-Host"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Port"}),(0,r.jsx)(t.td,{children:"X-Forwarded-Port"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Protocol"}),(0,r.jsx)(t.td,{children:"X-Forwarded-Proto"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Proxy Server's Hostname"}),(0,r.jsx)(t.td,{children:"X-Forwarded-Server"})]})]})]}),"\n",(0,r.jsxs)(t.p,{children:["For more details,\nplease check out the ",(0,r.jsx)(t.a,{href:"/doc/docs/routing/entrypoints#forwarded-headers",children:"forwarded header"})," documentation."]}),"\n",(0,r.jsx)(t.h2,{id:"how-mesh-is-storing-and-serving-tls-certificates",children:"How Mesh is Storing and Serving TLS Certificates?"}),"\n",(0,r.jsx)(t.h3,{id:"storing-tls-certificates",children:"Storing TLS Certificates"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"/doc/docs/https/tls",title:"Link to Mesh TLS docs",children:"TLS"})," certificates are either provided directly by the ",(0,r.jsx)(t.a,{href:"/doc/docs/getting-started/configuration-overview#the-dynamic-configuration",title:"Link to dynamic configuration overview",children:"dynamic configuration"})," from ",(0,r.jsx)(t.a,{href:"/doc/docs/https/tls#user-defined",title:"Link to the TLS configuration",children:"providers"}),",\nor by ",(0,r.jsx)(t.a,{href:"/doc/docs/https/acme#providers",title:"Link to ACME resolvers",children:"ACME resolvers"}),", which act themselves as providers internally."]}),"\n",(0,r.jsxs)(t.p,{children:["For each TLS certificate, Mesh produces an identifier used as a key to store it.\nThis identifier is constructed as the alphabetically ordered concatenation of the SANs ",(0,r.jsx)(t.code,{children:"DNSNames"})," and ",(0,r.jsx)(t.code,{children:"IPAddresses"})," of the TLScertificate."]}),"\n",(0,r.jsx)(t.h4,{id:"examples",children:"Examples:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"X509v3 Subject Alternative Name"}),(0,r.jsx)(t.th,{children:"TLS Certificate Identifier"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"DNS:example.com, IP Address:127.0.0.1"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"127.0.0.1,example.com"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"DNS:example.com, DNS:*.example.com"})}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"*.example.com,example.com"})})]})]})]}),"\n",(0,r.jsx)(t.p,{children:"The identifier is used to store TLS certificates in order to be later used to handle TLS connections.\nThis operation happens each time there are configuration changes."}),"\n",(0,r.jsx)(t.p,{children:"If multiple TLS certificates are provided with the same SANs definition (same identifier), only the one processed first is kept.\nBecause the dynamic configuration is aggregated from all providers,\nwhen processing it to gather TLS certificates,\nthere is no guarantee of the order in which they would be processed.\nThis means that along with configurations applied, it is possible that the TLS certificate retained for a given identifier differs."}),"\n",(0,r.jsx)(t.h3,{id:"serving-tls-certificates",children:"Serving TLS Certificates"}),"\n",(0,r.jsx)(t.p,{children:'For each incoming connection, Mesh is serving the "best" matching TLS certificate for the provided server name.'}),"\n",(0,r.jsx)(t.p,{children:"The TLS certificate selection process narrows down the list of TLS certificates matching the server name,\nand then selects the last TLS certificate in this list after having ordered it by the identifier alphabetically."}),"\n",(0,r.jsx)(t.h4,{id:"examples-1",children:"Examples:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Selected TLS Certificates Identifiers"}),(0,r.jsx)(t.th,{children:"Sorted TLS Certificates Identifiers"}),(0,r.jsx)(t.th,{children:"Served Certificate Identifier"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.code,{children:"127.0.0.1,example.com"}),",",(0,r.jsx)(t.code,{children:"*.example.com,example.com"})]}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.code,{children:"*.example.com,example.com"}),",",(0,r.jsx)(t.code,{children:"127.0.0.1,example.com"})]}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"127.0.0.1,example.com"})})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.code,{children:"*.example.com,example.com"}),",",(0,r.jsx)(t.code,{children:"example.com"})]}),(0,r.jsxs)(t.td,{children:[(0,r.jsx)(t.code,{children:"*.example.com,example.com"}),",",(0,r.jsx)(t.code,{children:"example.com"})]}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.code,{children:"example.com"})})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"caching-tls-certificates",children:"Caching TLS Certificates"}),"\n",(0,r.jsx)(t.p,{children:"While Mesh is serving the best matching TLS certificate for each incoming connection,\nthe selection process cost for each incoming connection is avoided thanks to a cache mechanism."}),"\n",(0,r.jsx)(t.p,{children:'Once a TLS certificate has been selected as the "best" TLS certificate for a server name,\nit is cached for an hour, avoiding the selection process for further connections.'}),"\n",(0,r.jsx)(t.p,{children:"Nonetheless, when a new configuration is applied, the cache is reset."}),"\n",(0,r.jsx)(t.h2,{id:"what-does-the-field-not-found-error-mean",children:'What does the "field not found" error mean?'}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-shell",children:"error: field not found, node: -badField-\n"})}),"\n",(0,r.jsx)(t.p,{children:'The "field not found" error occurs, when an unknown property is encountered in the dynamic or static configuration.'}),"\n",(0,r.jsx)(t.p,{children:"One way to check whether a configuration file is well-formed, is to validate it with:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://json.schemastore.org/mesh-v2.json",children:"JSON Schema of the static configuration"})}),"\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://json.schemastore.org/mesh-v2-file-provider.json",children:"JSON Schema of the dynamic configuration"})}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"why-are-some-resources-routers-middlewares-services-not-createdapplied",children:"Why are some resources (routers, middlewares, services...) not created/applied?"}),"\n",(0,r.jsx)(t.p,{children:"As a common tip, if a resource is dropped/not created by Mesh after the dynamic configuration was evaluated,\none should look for an error in the logs."}),"\n",(0,r.jsx)(t.p,{children:"If found, the error confirms that something went wrong while creating the resource,\nand the message should help in figuring out the mistake(s) in the configuration, and how to fix it."}),"\n",(0,r.jsxs)(t.p,{children:["When using the file provider,\none way to check if the dynamic configuration is well-formed is to validate it with the ",(0,r.jsx)(t.a,{href:"https://json.schemastore.org/mesh-v2-file-provider.json",children:"JSON Schema of the dynamic configuration"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"why-does-lets-encrypt-wildcard-certificate-renewalgeneration-with-dns-challenge-fail",children:"Why does Let's Encrypt wildcard certificate renewal/generation with DNS challenge fail?"}),"\n",(0,r.jsx)(t.p,{children:"If you're trying to renew wildcard certificates, with DNS challenge,\nand you're getting errors such as:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-txt",children:'msg="Error renewing certificate from LE: {example.com [*.example.com]}"\nproviderName=letsencrypt.acme error="error: one or more domains had a problem:\n[example.com] acme: error presenting token: gandiv5: unexpected authZone example.com. for fqdn example.com."\n'})}),"\n",(0,r.jsxs)(t.p,{children:["then it could be due to ",(0,r.jsx)(t.code,{children:"CNAME"})," support."]}),"\n",(0,r.jsxs)(t.p,{children:["In which case, you should make sure your infrastructure is properly set up for a\n",(0,r.jsx)(t.code,{children:"DNS"})," challenge that does not rely on ",(0,r.jsx)(t.code,{children:"CNAME"}),", and you should try disabling ",(0,r.jsx)(t.code,{children:"CNAME"})," support with:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-shell",children:"LEGO_DISABLE_CNAME_SUPPORT=true\n"})})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);