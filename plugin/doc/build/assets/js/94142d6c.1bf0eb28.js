"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[124],{965:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"reference/install-configuration/providers/kubernetes/kubernetes-ingress","title":"Mesh Kubernetes Ingress Documentation","description":"Understand the requirements, routing configuration, and how to set up Mesh Proxy as your Kubernetes Ingress Controller. Read the technical documentation.","source":"@site/docs/reference/install-configuration/providers/kubernetes/kubernetes-ingress.md","sourceDirName":"reference/install-configuration/providers/kubernetes","slug":"/reference/install-configuration/providers/kubernetes/kubernetes-ingress","permalink":"/doc/docs/reference/install-configuration/providers/kubernetes/kubernetes-ingress","draft":false,"unlisted":false,"editUrl":"https://github.com/opendatav/mesh/tree/main/packages/create-docusaurus/templates/shared/docs/reference/install-configuration/providers/kubernetes/kubernetes-ingress.md","tags":[],"version":"current","frontMatter":{"title":"Mesh Kubernetes Ingress Documentation","description":"Understand the requirements, routing configuration, and how to set up Mesh Proxy as your Kubernetes Ingress Controller. Read the technical documentation."},"sidebar":"tutorialSidebar","previous":{"title":"Mesh Kubernetes Gateway API Documentation","permalink":"/doc/docs/reference/install-configuration/providers/kubernetes/kubernetes-gateway"},"next":{"title":"Mesh Consul Documentation","permalink":"/doc/docs/reference/install-configuration/providers/kv/consul"}}');var r=s(4848),i=s(8453);const l={title:"Mesh Kubernetes Ingress Documentation",description:"Understand the requirements, routing configuration, and how to set up Mesh Proxy as your Kubernetes Ingress Controller. Read the technical documentation."},o="Mesh & Kubernetes",d={},c=[{value:"Configuration Example",id:"configuration-example",level:2},{value:"Configuration Options",id:"configuration-options",level:2},{value:"<code>endpoint</code>",id:"endpoint",level:3},{value:"<code>ingressEndpoint.publishedService</code>",id:"ingressendpointpublishedservice",level:3},{value:"Routing Configuration",id:"routing-configuration",level:2},{value:"Further",id:"further",level:2}];function a(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"mesh--kubernetes",children:"Mesh & Kubernetes"})}),"\n",(0,r.jsxs)(t.p,{children:["The Mesh Kubernetes Ingress provider is a Kubernetes Ingress controller; i.e,\nit manages access to cluster services by supporting the ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/ingress/",children:"Ingress"})," specification."]}),"\n",(0,r.jsx)(t.h2,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,r.jsxs)(t.p,{children:["You can enable the ",(0,r.jsx)(t.code,{children:"kubernetesIngress"})," provider as detailed below:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="File (YAML)"',children:"providers:\n  kubernetesIngress: {}\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-toml",metastring:'tab="File (TOML)"',children:"[providers.kubernetesIngress]\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",metastring:'tab="CLI"',children:"--providers.kubernetesingress=true\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="Helm Chart Values"',children:"## Values file\nproviders:\n  kubernetesIngress:\n    enabled: true\n"})}),"\n",(0,r.jsx)(t.p,{children:"The provider then watches for incoming ingresses events, such as the example below,\nand derives the corresponding dynamic configuration from it,\nwhich in turn creates the resulting routers, services, handlers, etc."}),"\n",(0,r.jsx)(t.h2,{id:"configuration-options",children:"Configuration Options"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Field"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Description"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Default"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Required"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"providers.providersThrottleDuration"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Minimum amount of time to wait for, after a configuration reload, before taking into account any new configuration refresh event.",(0,r.jsx)("br",{}),"If multiple events occur within this time, only the most recent one is taken into account, and all others are discarded.",(0,r.jsx)("br",{}),(0,r.jsx)(t.strong,{children:"This option cannot be set per provider, but the throttling algorithm applies to each of them independently."})]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"2s"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"providers.kubernetesIngress.endpoint"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Server endpoint URL.",(0,r.jsx)("br",{}),"More information ",(0,r.jsx)(t.a,{href:"#endpoint",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"providers.kubernetesIngress.token"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Bearer token used for the Kubernetes client configuration."}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"providers.kubernetesIngress.certAuthFilePath"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Path to the certificate authority file.",(0,r.jsx)("br",{}),"Used for the Kubernetes client configuration."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"providers.kubernetesCRD.namespaces"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Array of namespaces to watch.",(0,r.jsx)("br",{}),"If left empty, watch all namespaces."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"}}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"providers.kubernetesIngress.labelselector"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Allow filtering on Ingress objects using label selectors.",(0,r.jsx)("br",{}),"No effect on Kubernetes ",(0,r.jsx)(t.code,{children:"Secrets"}),", ",(0,r.jsx)(t.code,{children:"EndpointSlices"})," and ",(0,r.jsx)(t.code,{children:"Services"}),".",(0,r.jsx)("br",{}),"See ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors",children:"label-selectors"})," for details."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"providers.kubernetesIngress.ingressClass"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["The ",(0,r.jsx)(t.code,{children:"IngressClass"})," resource name or the ",(0,r.jsx)(t.code,{children:"kubernetes.io/ingress.class"})," annotation value that identifies resource objects to be processed.",(0,r.jsx)("br",{}),"If empty, resources missing the annotation, having an empty value, or the value ",(0,r.jsx)(t.code,{children:"Mesh"})," are processed."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"providers.kubernetesIngress.disableIngressClassLookup"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Prevent to discover IngressClasses in the cluster.",(0,r.jsx)("br",{}),"It alleviates the requirement of giving Mesh the rights to look IngressClasses up.",(0,r.jsx)("br",{}),"Ignore Ingresses with IngressClass.",(0,r.jsx)("br",{}),"Annotations are not affected by this option."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"providers.kubernetesIngress."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"ingressEndpoint.hostname"})]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Hostname used for Kubernetes Ingress endpoints."}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"providers.kubernetesIngress."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"ingressEndpoint.ip"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["This IP will get copied to the Ingress ",(0,r.jsx)(t.code,{children:"status.loadbalancer.ip"}),", and currently only supports one IP value (IPv4 or IPv6)."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"providers.kubernetesIngress."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"ingressEndpoint.publishedService"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["The Kubernetes service to copy status from.",(0,r.jsx)("br",{}),"More information ",(0,r.jsx)(t.a,{href:"#ingressendpointpublishedservice",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"providers.kubernetesIngress.throttleDuration"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Minimum amount of time to wait between two Kubernetes events before producing a new configuration.",(0,r.jsx)("br",{}),"This prevents a Kubernetes cluster that updates many times per second from continuously changing your Mesh configuration.",(0,r.jsx)("br",{}),"If empty, every event is caught."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"0s"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"providers.kubernetesIngress.allowEmptyServices"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Allows creating a route to reach a service that has no endpoint available.",(0,r.jsx)("br",{}),"It allows Mesh to handle the requests and responses targeting this service (applying middleware or observability operations) before returning a ",(0,r.jsx)(t.code,{children:"503"})," HTTP Status."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"providers.kubernetesIngress.allowCrossNamespace"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Allows the ",(0,r.jsx)(t.code,{children:"Ingress"})," to reference resources in namespaces other than theirs."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"providers.kubernetesIngress.allowExternalNameServices"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Allows the ",(0,r.jsx)(t.code,{children:"Ingress"})," to reference ExternalName services."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"providers.kubernetesIngress.nativeLBByDefault"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Allow using the Kubernetes Service load balancing between the pods instead of the one provided by Mesh for every ",(0,r.jsx)(t.code,{children:"Ingress"})," by default.",(0,r.jsx)("br",{}),"It can br overridden in the ",(0,r.jsx)(t.a,{href:"/doc/docs/routing/services/#serverstransport",children:(0,r.jsx)(t.code,{children:"ServerTransport"})}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"providers.kubernetesIngress.disableClusterScopeResources"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Prevent from discovering cluster scope resources (",(0,r.jsx)(t.code,{children:"IngressClass"})," and ",(0,r.jsx)(t.code,{children:"Nodes"}),").",(0,r.jsx)("br",{}),"By doing so, it alleviates the requirement of giving Mesh the rights to look up for cluster resources.",(0,r.jsx)("br",{}),"Furthermore, Mesh  will not handle Ingresses with IngressClass references, therefore such Ingresses will be ignored (please note that annotations are not affected by this option).",(0,r.jsx)("br",{}),"This will also prevent from using the ",(0,r.jsx)(t.code,{children:"NodePortLB"})," options on services."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"endpoint",children:(0,r.jsx)(t.code,{children:"endpoint"})}),"\n",(0,r.jsx)(t.p,{children:"The Kubernetes server endpoint URL."}),"\n",(0,r.jsxs)(t.p,{children:["When deployed into Kubernetes, Mesh reads the environment variables ",(0,r.jsx)(t.code,{children:"KUBERNETES_SERVICE_HOST"}),"\nand ",(0,r.jsx)(t.code,{children:"KUBERNETES_SERVICE_PORT"})," or ",(0,r.jsx)(t.code,{children:"KUBECONFIG"})," to construct the endpoint."]}),"\n",(0,r.jsxs)(t.p,{children:["The access token is looked up in ",(0,r.jsx)(t.code,{children:"/var/run/secrets/kubernetes.io/serviceaccount/token"}),"\nand the SSL CA certificate in ",(0,r.jsx)(t.code,{children:"/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"}),".\nBoth are mounted automatically when deployed inside Kubernetes."]}),"\n",(0,r.jsx)(t.p,{children:"The endpoint may be specified to override the environment variable values inside\na cluster."}),"\n",(0,r.jsx)(t.p,{children:"When the environment variables are not found, Mesh tries to connect to the\nKubernetes API server with an external-cluster client."}),"\n",(0,r.jsxs)(t.p,{children:["In this case, the endpoint is required.\nSpecifically, it may be set to the URL used by ",(0,r.jsx)(t.code,{children:"kubectl proxy"})," to connect to a Kubernetes\ncluster using the granted authentication and authorization of the associated kubeconfig."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="File (YAML)"',children:'providers:\n  kubernetesIngress:\n    endpoint: "http://localhost:8080"\n    # ...\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-toml",metastring:'tab="File (TOML)"',children:'[providers.kubernetesIngress]\n  endpoint = "http://localhost:8080"\n  # ...\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",metastring:'tab="CLI"',children:"--providers.kubernetesingress.endpoint=http://localhost:8080\n"})}),"\n",(0,r.jsx)(t.h3,{id:"ingressendpointpublishedservice",children:(0,r.jsx)(t.code,{children:"ingressEndpoint.publishedService"})}),"\n",(0,r.jsxs)(t.p,{children:["Format: ",(0,r.jsx)(t.code,{children:"namespace/servicename"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"The Kubernetes service to copy status from,\ndepending on the service type:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"ClusterIP:"})," The ExternalIPs of the service will be propagated to the ingress status."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"NodePort:"})," The ExternalIP addresses of the nodes in the cluster will be propagated to the ingress status."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"LoadBalancer:"})," The IPs from the service's ",(0,r.jsx)(t.code,{children:"loadBalancer.status"})," field (which contains the endpoints provided by the load balancer) will be propagated to the ingress status."]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"When using third-party tools such as External-DNS, this option enables the copying of external service IPs to the ingress resources."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="File (YAML)"',children:'providers:\n  kubernetesIngress:\n    ingressEndpoint:\n      publishedService: "namespace/foo-service"\n    # ...\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-toml",metastring:'tab="File (TOML)"',children:'[providers.kubernetesIngress.ingressEndpoint]\n  publishedService = "namespace/foo-service"\n  # ...\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-bash",metastring:'tab="CLI"',children:"--providers.kubernetesingress.ingressendpoint.publishedservice=namespace/foo-service\n"})}),"\n",(0,r.jsx)(t.h2,{id:"routing-configuration",children:"Routing Configuration"}),"\n",(0,r.jsxs)(t.p,{children:["See the dedicated section in ",(0,r.jsx)(t.a,{href:"/doc/docs/routing/providers/kubernetes-ingress",children:"routing"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"further",children:"Further"}),"\n",(0,r.jsxs)(t.p,{children:["To learn more about the various aspects of the Ingress specification that\nMesh supports,\nmany examples of Ingresses definitions are located in the test\n",(0,r.jsx)(t.a,{href:"https://github.com/Mesh/Mesh/tree/v3.1/pkg/provider/kubernetes/ingress/fixtures",children:"examples"}),"\nof the Mesh repository."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>l,x:()=>o});var n=s(6540);const r={},i=n.createContext(r);function l(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);