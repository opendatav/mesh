"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[7552],{749:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"reference/routing-configuration/tcp/tls","title":"Mesh TLS Documentation","description":"Learn how to configure the transport layer security (TLS) connection for TCP services in Mesh Proxy. Read the technical documentation.","source":"@site/docs/reference/routing-configuration/tcp/tls.md","sourceDirName":"reference/routing-configuration/tcp","slug":"/reference/routing-configuration/tcp/tls","permalink":"/doc/docs/reference/routing-configuration/tcp/tls","draft":false,"unlisted":false,"editUrl":"https://github.com/opendatav/mesh/tree/main/packages/create-docusaurus/templates/shared/docs/reference/routing-configuration/tcp/tls.md","tags":[],"version":"current","frontMatter":{"title":"Mesh TLS Documentation","description":"Learn how to configure the transport layer security (TLS) connection for TCP services in Mesh Proxy. Read the technical documentation."},"sidebar":"tutorialSidebar","previous":{"title":"Mesh TCP Services Documentation","permalink":"/doc/docs/reference/routing-configuration/tcp/service"},"next":{"title":"Mesh UDP Routers Rules & Priority Documentation","permalink":"/doc/docs/reference/routing-configuration/udp/router/rules-priority"}}');var r=n(4848),o=n(8453);const i={title:"Mesh TLS Documentation",description:"Learn how to configure the transport layer security (TLS) connection for TCP services in Mesh Proxy. Read the technical documentation."},l=void 0,c={},a=[{value:"General",id:"general",level:2},{value:"Configuration Example",id:"configuration-example",level:2},{value:"Configuration Options",id:"configuration-options",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"general",children:"General"}),"\n",(0,r.jsxs)(t.p,{children:["When a router is configured to handle HTTPS traffic, include a ",(0,r.jsx)(t.code,{children:"tls"})," field in its definition. This field tells Mesh that the router should process only TLS requests and ignore non-TLS traffic."]}),"\n",(0,r.jsx)(t.p,{children:"By default, a router with a TLS field will terminate the TLS connections, meaning that it will send decrypted data to the services."}),"\n",(0,r.jsx)(t.h2,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="Structured (YAML)"',children:'tcp:\n  routers:\n    my-tls-router:\n      rule: "HostSNI(`example.com`)"\n      service: "my-tcp-service"\n      tls:\n        passthrough: true\n        options: "my-tls-options"\n        domains:\n          - main: "example.com"\n            sans:\n              - "www.example.com"\n              - "api.example.com"\n        certResolver: "myresolver"\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-toml",metastring:'tab="Structured (TOML)"',children:'[tcp.routers.my-tls-router]\n  rule = "HostSNI(`example.com`)"\n  service = "my-tcp-service"\n\n  [tcp.routers.my-tls-router.tls]\n    passthrough = true\n    options = "my-tls-options"\n    certResolver = "myresolver"\n\n    [[tcp.routers.my-tls-router.tls.domains]]\n      main = "example.com"\n      sans = ["www.example.com", "api.example.com"]\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="Labels"',children:'labels:\n  - "Mesh.tcp.routers.my-tls-router.tls=true"\n  - "Mesh.tcp.routers.my-tls-router.rule=HostSNI(`example.com`)"\n  - "Mesh.tcp.routers.my-tls-router.service=my-tcp-service"\n  - "Mesh.tcp.routers.my-tls-router.tls.passthrough=true"\n  - "Mesh.tcp.routers.my-tls-router.tls.options=my-tls-options"\n  - "Mesh.tcp.routers.my-tls-router.tls.certResolver=myresolver"\n  - "Mesh.tcp.routers.my-tls-router.tls.domains[0].main=example.com"\n  - "Mesh.tcp.routers.my-tls-router.tls.domains[0].sans=www.example.com,api.example.com"\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-json",metastring:'tab="Tags"',children:'{\n  //...\n  "Tags": [\n    "Mesh.tcp.routers.my-tls-router.tls=true"\n    "Mesh.tcp.routers.my-tls-router.rule=HostSNI(`example.com`)",\n    "Mesh.tcp.routers.my-tls-router.service=my-tcp-service",\n    "Mesh.tcp.routers.my-tls-router.tls.passthrough=true",\n    "Mesh.tcp.routers.my-tls-router.tls.options=my-tls-options",\n    "Mesh.tcp.routers.my-tls-router.tls.certResolver=myresolver",\n    "Mesh.tcp.routers.my-tls-router.tls.domains[0].main=example.com",\n    "Mesh.tcp.routers.my-tls-router.tls.domains[0].sans=www.example.com,api.example.com"\n  ]\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:'??? info "Postgres STARTTLS"'}),"\n",(0,r.jsx)(t.p,{children:"Mesh supports the Postgres STARTTLS protocol,\nwhich allows TLS routing for Postgres connections."}),"\n",(0,r.jsx)(t.p,{children:"To do so, Mesh reads the first bytes sent by a Postgres client,\nidentifies if they correspond to the message of a STARTTLS negotiation,\nand, if so, acknowledges and signals the client that it can start the TLS handshake."}),"\n",(0,r.jsxs)(t.p,{children:["Please note/remember that there are subtleties inherent to STARTTLS in whether the connection ends up being a TLS one or not.\nThese subtleties depend on the ",(0,r.jsx)(t.code,{children:"sslmode"})," value in the client configuration (and on the server authentication rules).\nTherefore, it is recommended to use the ",(0,r.jsx)(t.code,{children:"require"})," value for the ",(0,r.jsx)(t.code,{children:"sslmode"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"Afterwards, the TLS handshake, and routing based on TLS, can proceed as expected."}),"\n",(0,r.jsx)(t.p,{children:'!!! warning "Postgres STARTTLS with TCP TLS PassThrough routers"'}),"\n",(0,r.jsxs)(t.p,{children:["As mentioned above, the ",(0,r.jsx)(t.code,{children:"sslmode"})," configuration parameter does have an impact on whether a STARTTLS session will succeed.\nIn particular in the context of TCP TLS PassThrough, some of the values (such as ",(0,r.jsx)(t.code,{children:"allow"}),") do not even make sense.\nWhich is why, once more it is recommended to use the ",(0,r.jsx)(t.code,{children:"require"})," value."]}),"\n",(0,r.jsx)(t.h2,{id:"configuration-options",children:"Configuration Options"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Field"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Description"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Default"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Required"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"passthrough"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'Defines whether the requests should be forwarded "as is", keeping all data encrypted.'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"options"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["enables fine-grained control of the TLS parameters. It refers to a ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/routing-configuration/http/tls/tls-certificates#tls-options",children:"TLS Options"})," and will be applied only if a ",(0,r.jsx)(t.code,{children:"HostSNI"})," rule is defined."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"domains"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Defines a set of SANs (alternative domains) for each main domain. Every domain must have A/AAAA records pointing to Mesh. Each domain & SAN will lead to a certificate request."}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"[]"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"certResolver"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["If defined, Mesh will try to generate certificates based on routers ",(0,r.jsx)(t.code,{children:"Host"})," & ",(0,r.jsx)(t.code,{children:"HostSNI"})," rules."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>l});var s=n(6540);const r={},o=s.createContext(r);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);