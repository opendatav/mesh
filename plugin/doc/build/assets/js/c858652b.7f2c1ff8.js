"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[6734],{7677:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"routing/providers/kubernetes-crd","title":"Routing Configuration for Mesh CRD","description":"Understand the routing configuration for the Kubernetes IngressRoute & Mesh CRD. Read the technical documentation.","source":"@site/docs/routing/providers/kubernetes-crd.md","sourceDirName":"routing/providers","slug":"/routing/providers/kubernetes-crd","permalink":"/doc/docs/routing/providers/kubernetes-crd","draft":false,"unlisted":false,"editUrl":"https://github.com/opendatav/mesh/tree/main/packages/create-docusaurus/templates/shared/docs/routing/providers/kubernetes-crd.md","tags":[],"version":"current","frontMatter":{"title":"Routing Configuration for Mesh CRD","description":"Understand the routing configuration for the Kubernetes IngressRoute & Mesh CRD. Read the technical documentation."},"sidebar":"tutorialSidebar","previous":{"title":"Mesh ECS Documentation","permalink":"/doc/docs/routing/providers/ecs"},"next":{"title":"Mesh Kubernetes Gateway","permalink":"/doc/docs/routing/providers/kubernetes-gateway"}}');var t=s(4848),i=s(8453);const a={title:"Routing Configuration for Mesh CRD",description:"Understand the routing configuration for the Kubernetes IngressRoute & Mesh CRD. Read the technical documentation."},c="Mesh & Kubernetes",d={},o=[{value:"Configuration Examples",id:"configuration-examples",level:2},{value:"Routing Configuration",id:"routing-configuration",level:2},{value:"Custom Resource Definition (CRD)",id:"custom-resource-definition-crd",level:3},{value:"Kind: <code>IngressRoute</code>",id:"kind-ingressroute",level:3},{value:"Load Balancing",id:"load-balancing",level:4},{value:"Kind: <code>Middleware</code>",id:"kind-middleware",level:3},{value:"Kind: <code>MeshService</code>",id:"kind-meshservice",level:3},{value:"Weighted Round Robin",id:"weighted-round-robin",level:4},{value:"Mirroring",id:"mirroring",level:4},{value:"Stickiness and load-balancing",id:"stickiness-and-load-balancing",level:4},{value:"Kind: <code>IngressRouteTCP</code>",id:"kind-ingressroutetcp",level:3},{value:"Kind: <code>MiddlewareTCP</code>",id:"kind-middlewaretcp",level:3},{value:"Kind: <code>IngressRouteUDP</code>",id:"kind-ingressrouteudp",level:3},{value:"Kind: <code>TLSOption</code>",id:"kind-tlsoption",level:3},{value:"Kind: <code>TLSStore</code>",id:"kind-tlsstore",level:3},{value:"Kind: <code>ServersTransport</code>",id:"kind-serverstransport",level:3},{value:"ServersTransport reference",id:"serverstransport-reference",level:4},{value:"Kind: <code>ServersTransportTCP</code>",id:"kind-serverstransporttcp",level:3},{value:"ServersTransportTCP reference",id:"serverstransporttcp-reference",level:4},{value:"Further",id:"further",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"mesh--kubernetes",children:"Mesh & Kubernetes"})}),"\n",(0,t.jsx)(n.p,{children:"The Kubernetes Ingress Controller, The Custom Resource Way."}),"\n",(0,t.jsx)(n.h2,{id:"configuration-examples",children:"Configuration Examples"}),"\n",(0,t.jsx)(n.p,{children:'??? example "Configuring KubernetesCRD and Deploying/Exposing Services"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Resource Definition"',children:'# All resources definition must be declared\n--8<-- "content/reference/dynamic-configuration/kubernetes-crd-definition-v1.yml"\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="RBAC"',children:'--8<-- "content/reference/dynamic-configuration/kubernetes-crd-rbac.yml"\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Mesh"',children:"apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: mesh-ingress-controller\n\n---\nkind: Deployment\napiVersion: apps/v1\nmetadata:\n  name: Mesh\n  labels:\n    app: Mesh\n\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: Mesh\n  template:\n    metadata:\n      labels:\n        app: Mesh\n    spec:\n      serviceAccountName: mesh-ingress-controller\n      containers:\n        - name: Mesh\n          image: Mesh:v3.4\n          args:\n            - --log.level=DEBUG\n            - --api\n            - --api.insecure\n            - --entryPoints.web.address=:80\n            - --entryPoints.tcpep.address=:8000\n            - --entryPoints.udpep.address=:9000/udp\n            - --providers.kubernetescrd\n          ports:\n            - name: web\n              containerPort: 80\n            - name: admin\n              containerPort: 8080\n            - name: tcpep\n              containerPort: 8000\n            - name: udpep\n              containerPort: 9000\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: Mesh\nspec:\n  type: LoadBalancer\n  selector:\n    app: Mesh\n  ports:\n    - protocol: TCP\n      port: 80\n      name: web\n      targetPort: 80\n    - protocol: TCP\n      port: 8080\n      name: admin\n      targetPort: 8080\n    - protocol: TCP\n      port: 8000\n      name: tcpep\n      targetPort: 8000\n \n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: Meshudp\nspec:\n  type: LoadBalancer\n  selector:\n    app: Mesh\n  ports:\n    - protocol: UDP\n      port: 9000\n      name: udpep\n      targetPort: 9000\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: myingressroute\n  namespace: default\n\nspec:\n  entryPoints:\n    - web\n\n  routes:\n  - match: Host(`foo`) && PathPrefix(`/bar`)\n    kind: Rule\n    services:\n    - name: whoami\n      port: 80\n\n---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRouteTCP\nmetadata:\n  name: ingressroute.tcp\n  namespace: default\n\nspec:\n  entryPoints:\n    - tcpep\n  routes:\n  - match: HostSNI(`bar`)\n    services:\n      - name: whoamitcp\n        port: 8080\n\n---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRouteUDP\nmetadata:\n  name: ingressroute.udp\n  namespace: default\n\nspec:\n  entryPoints:\n    - udpep\n  routes:\n  - services:\n      - name: whoamiudp\n        port: 8080\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Whoami"',children:"kind: Deployment\napiVersion: apps/v1\nmetadata:\n  name: whoami\n  namespace: default\n  labels:\n    app: Meshlabs\n    name: whoami\n\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: Meshlabs\n      task: whoami\n  template:\n    metadata:\n      labels:\n        app: Meshlabs\n        task: whoami\n    spec:\n      containers:\n        - name: whoami\n          image: Mesh/whoami\n          ports:\n            - containerPort: 80\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: whoami\n  namespace: default\n\nspec:\n  ports:\n    - name: http\n      port: 80\n  selector:\n    app: Meshlabs\n    task: whoami\n\n---\nkind: Deployment\napiVersion: apps/v1\nmetadata:\n  name: whoamitcp\n  namespace: default\n  labels:\n    app: Meshlabs\n    name: whoamitcp\n\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: Meshlabs\n      task: whoamitcp\n  template:\n    metadata:\n      labels:\n        app: Meshlabs\n        task: whoamitcp\n    spec:\n      containers:\n        - name: whoamitcp\n          image: Mesh/whoamitcp\n          ports:\n            - containerPort: 8080\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: whoamitcp\n  namespace: default\n\nspec:\n  ports:\n    - protocol: TCP\n      port: 8080\n  selector:\n    app: Meshlabs\n    task: whoamitcp\n\n---\nkind: Deployment\napiVersion: apps/v1\nmetadata:\n  name: whoamiudp\n  namespace: default\n  labels:\n    app: Meshlabs\n    name: whoamiudp\n\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: Meshlabs\n      task: whoamiudp\n  template:\n    metadata:\n      labels:\n        app: Meshlabs\n        task: whoamiudp\n    spec:\n      containers:\n        - name: whoamiudp\n          image: Mesh/whoamiudp:latest\n          ports:\n            - containerPort: 8080\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: whoamiudp\n  namespace: default\n\nspec:\n  ports:\n    - port: 8080\n  selector:\n    app: Meshlabs\n    task: whoamiudp\n"})}),"\n",(0,t.jsx)(n.h2,{id:"routing-configuration",children:"Routing Configuration"}),"\n",(0,t.jsx)(n.h3,{id:"custom-resource-definition-crd",children:"Custom Resource Definition (CRD)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["You can find an exhaustive list, generated from Mesh's source code, of the custom resources and their attributes in ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/dynamic-configuration/kubernetes-crd",children:"the reference page"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Validate that ",(0,t.jsx)(n.a,{href:"/doc/docs/providers/kubernetes-crd#requirements",children:"the prerequisites"})," are fulfilled before using the Mesh custom resources."]}),"\n",(0,t.jsx)(n.li,{children:"Mesh CRDs are building blocks that you can assemble according to your needs."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"You can find an excerpt of the available custom resources in the table below:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Kind"}),(0,t.jsx)(n.th,{children:"Purpose"}),(0,t.jsx)(n.th,{children:"Concept Behind"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"#kind-ingressroute",children:"IngressRoute"})}),(0,t.jsx)(n.td,{children:"HTTP Routing"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#configuring-http-routers",children:"HTTP router"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"#kind-middleware",children:"Middleware"})}),(0,t.jsx)(n.td,{children:"Tweaks the HTTP requests before they are sent to your service"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/doc/docs/middlewares/http/overview",children:"HTTP Middlewares"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"#kind-Meshservice",children:"MeshService"})}),(0,t.jsx)(n.td,{children:"Abstraction for HTTP loadbalancing/mirroring"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/doc/docs/routing/services/#configuring-http-services",children:"HTTP service"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"#kind-ingressroutetcp",children:"IngressRouteTCP"})}),(0,t.jsx)(n.td,{children:"TCP Routing"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#configuring-tcp-routers",children:"TCP router"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"#kind-middlewaretcp",children:"MiddlewareTCP"})}),(0,t.jsx)(n.td,{children:"Tweaks the TCP requests before they are sent to your service"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/doc/docs/middlewares/tcp/overview",children:"TCP Middlewares"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"#kind-ingressrouteudp",children:"IngressRouteUDP"})}),(0,t.jsx)(n.td,{children:"UDP Routing"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#configuring-udp-routers",children:"UDP router"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"#kind-tlsoption",children:"TLSOptions"})}),(0,t.jsx)(n.td,{children:"Allows to configure some parameters of the TLS connection"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/doc/docs/https/tls#tls-options",children:"TLSOptions"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"#kind-tlsstore",children:"TLSStores"})}),(0,t.jsx)(n.td,{children:"Allows to configure the default TLS store"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/doc/docs/https/tls#certificates-stores",children:"TLSStores"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"#kind-serverstransport",children:"ServersTransport"})}),(0,t.jsx)(n.td,{children:"Allows to configure the transport between Mesh and the backends"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"../../services/#serverstransport_1",children:"ServersTransport"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"#kind-serverstransporttcp",children:"ServersTransportTCP"})}),(0,t.jsx)(n.td,{children:"Allows to configure the transport between Mesh and the backends"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"../../services/#serverstransport_3",children:"TCP ServersTransport"})})]})]})]}),"\n",(0,t.jsxs)(n.h3,{id:"kind-ingressroute",children:["Kind: ",(0,t.jsx)(n.code,{children:"IngressRoute"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"IngressRoute"})," is the CRD implementation of a ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#configuring-http-routers",children:"Mesh HTTP router"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Register the ",(0,t.jsx)(n.code,{children:"IngressRoute"})," ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/dynamic-configuration/kubernetes-crd#definitions",children:"kind"})," in the Kubernetes cluster before creating ",(0,t.jsx)(n.code,{children:"IngressRoute"})," objects."]}),"\n",(0,t.jsx)(n.p,{children:'!!! info "IngressRoute Attributes"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: foo\n  namespace: bar\nspec:\n  entryPoints:                      # [1]\n    - foo\n  routes:                           # [2]\n  - kind: Rule\n    match: Host(`test.example.com`) # [3]\n    priority: 10                    # [4]\n    middlewares:                    # [5]\n    - name: middleware1             # [6]\n      namespace: default            # [7]\n    observability:                  # [8]\n      accesslogs: true              # [9]    \n      metrics: true                 # [10]\n      tracing: true                 # [11]\n    services:                       # [12]\n    - kind: Service\n      name: foo\n      namespace: default\n      passHostHeader: true\n      port: 80                      # [13]\n      responseForwarding:\n        flushInterval: 1ms\n      scheme: https\n      serversTransport: transport   # [14]\n      healthCheck:                  # [15]\n        path: /health\n        interval: 15s\n      sticky:\n        cookie:\n          httpOnly: true\n          name: cookie\n          secure: true\n          sameSite: none\n          maxAge: 42  \n          path: /foo\n          domain: foo.com\n      strategy: wrr                 # [16]\n      weight: 10\n      nativeLB: true                # [17]\n      nodePortLB: true              # [18]\n  tls:                              # [19]\n    secretName: supersecret         # [20]\n    options:                        # [21]\n      name: opt                     # [22]\n      namespace: default            # [23]\n    certResolver: foo               # [24]\n    domains:                        # [25]\n    - main: example.net             # [26]\n      sans:                         # [27]\n      - a.example.net\n      - b.example.net\n"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Ref"}),(0,t.jsx)(n.th,{children:"Attribute"}),(0,t.jsx)(n.th,{children:"Purpose"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[1]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"entryPoints"})}),(0,t.jsxs)(n.td,{children:["List of ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#entrypoints",children:"entry points"})," names"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[2]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes"})}),(0,t.jsx)(n.td,{children:"List of routes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[3]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].match"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#rule",children:"rule"})," corresponding to an underlying router."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[4]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].priority"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#priority",children:"priority"})," to disambiguate rules of the same length, for route matching"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[5]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].middlewares"})}),(0,t.jsxs)(n.td,{children:["List of reference to ",(0,t.jsx)(n.a,{href:"#kind-middleware",children:"Middleware"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[6]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"middlewares[n].name"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"#kind-middleware",children:"Middleware"})," name"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[7]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"middlewares[n].namespace"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"#kind-middleware",children:"Middleware"})," namespace. It can be omitted when the Middleware is in the IngressRoute namespace."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[8]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].observability"})}),(0,t.jsx)(n.td,{children:"Defines the route observability configuration."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[9]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"observability.accesslogs"})}),(0,t.jsxs)(n.td,{children:["Defines whether the route will produce ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#accesslogs",children:"access-logs"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[10]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"observability.metrics"})}),(0,t.jsxs)(n.td,{children:["Defines whether the route will produce ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#metrics",children:"metrics"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[11]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"observability.tracing"})}),(0,t.jsxs)(n.td,{children:["Defines whether the route will produce ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#tracing",children:"traces"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[12]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].services"})}),(0,t.jsxs)(n.td,{children:["List of any combination of ",(0,t.jsx)(n.a,{href:"#kind-Meshservice",children:"MeshService"})," and reference to a ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," (See below for ",(0,t.jsx)(n.code,{children:"ExternalName Service"})," setup)"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[13]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].port"})}),(0,t.jsxs)(n.td,{children:["Defines the port of a ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"}),". This can be a reference to a named port."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[14]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].serversTransport"})}),(0,t.jsxs)(n.td,{children:["Defines the reference to a ",(0,t.jsx)(n.a,{href:"#kind-serverstransport",children:"ServersTransport"}),". The ServersTransport namespace is assumed to be the ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," namespace (see ",(0,t.jsx)(n.a,{href:"#serverstransport-reference",children:"ServersTransport reference"}),")."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[15]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].healthCheck"})}),(0,t.jsxs)(n.td,{children:["Defines the HealthCheck when service references a ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," of type ExternalName."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[16]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].strategy"})}),(0,t.jsxs)(n.td,{children:["Defines the load-balancing strategy for the load-balancer. Supported values are ",(0,t.jsx)(n.code,{children:"wrr"})," and ",(0,t.jsx)(n.code,{children:"p2c"}),", please refer to the ",(0,t.jsx)(n.a,{href:"../routing/services/#load-balancing-strategy",children:"Load Balancing documentation"})," for more information."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[17]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].nativeLB"})}),(0,t.jsx)(n.td,{children:"Controls, when creating the load-balancer, whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[18]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].nodePortLB"})}),(0,t.jsx)(n.td,{children:"Controls, when creating the load-balancer, whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[19]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls"})}),(0,t.jsxs)(n.td,{children:["Defines ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#tls",children:"TLS"})," certificate configuration"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[20]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.secretName"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/configuration/secret/",children:"secret"})," name used to store the certificate (in the ",(0,t.jsx)(n.code,{children:"IngressRoute"})," namespace)"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[21]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.options"})}),(0,t.jsxs)(n.td,{children:["Defines the reference to a ",(0,t.jsx)(n.a,{href:"#kind-tlsoption",children:"TLSOption"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[22]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"options.name"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"#kind-tlsoption",children:"TLSOption"})," name"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[23]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"options.namespace"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"#kind-tlsoption",children:"TLSOption"})," namespace"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[24]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.certResolver"})}),(0,t.jsxs)(n.td,{children:["Defines the reference to a ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#certresolver",children:"CertResolver"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[25]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.domains"})}),(0,t.jsxs)(n.td,{children:["List of ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#domains",children:"domains"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[26]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"domains[n].main"})}),(0,t.jsx)(n.td,{children:"Defines the main domain name"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[27]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"domains[n].sans"})}),(0,t.jsx)(n.td,{children:"List of SANs (alternative domains)"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:'??? example "Declaring an IngressRoute"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"# All resources definition must be declared\napiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test-name\n  namespace: default\nspec:\n  entryPoints:\n    - web\n  routes:\n  - kind: Rule\n    match: Host(`test.example.com`)\n    middlewares:\n    - name: middleware1\n      namespace: default\n    priority: 10\n    services:\n    - kind: Service\n      name: foo\n      namespace: default\n      passHostHeader: true\n      port: 80\n      responseForwarding:\n        flushInterval: 1ms\n      scheme: https\n      sticky:\n        cookie:\n          httpOnly: true\n          name: cookie\n          secure: true\n      strategy: RoundRobin\n      weight: 10\n  tls:\n    certResolver: foo\n    domains:\n    - main: example.net\n      sans:\n      - a.example.net\n      - b.example.net\n    options:\n      name: opt\n      namespace: default\n    secretName: supersecret\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Middlewares"',children:"# All resources definition must be declared\n# Prefixing with /foo\napiVersion: Mesh.io/v1alpha1\nkind: Middleware\nmetadata:\n  name: middleware1\n  namespace: default\nspec:\n  addPrefix:\n    prefix: /foo\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="TLSOption"',children:"apiVersion: Mesh.io/v1alpha1\nkind: TLSOption\nmetadata:\n  name: opt\n  namespace: default\n\nspec:\n  minVersion: VersionTLS12\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Secret"',children:"apiVersion: v1\nkind: Secret\nmetadata:\n  name: supersecret\n\ndata:\n  tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0=\n  tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0=\n"})}),"\n",(0,t.jsx)(n.p,{children:'!!! important "Configuring Backend Protocol"'}),"\n",(0,t.jsx)(n.p,{children:"There are 3 ways to configure the backend protocol for communication between Mesh and your pods:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Setting the scheme explicitly (http/https/h2c)"}),"\n",(0,t.jsx)(n.li,{children:"Configuring the name of the kubernetes service port to start with https (https)"}),"\n",(0,t.jsx)(n.li,{children:"Setting the kubernetes service port to use port 443 (https)"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"If you do not configure the above, Mesh will assume an http connection."}),"\n",(0,t.jsx)(n.p,{children:'!!! important "Using Kubernetes ExternalName Service"'}),"\n",(0,t.jsxs)(n.p,{children:["Mesh backends creation needs a port to be set, however Kubernetes ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/#externalname",children:"ExternalName Service"})," could be defined without any port.\nAccordingly, Mesh supports defining a port in two ways:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["only on ",(0,t.jsx)(n.code,{children:"IngressRoute"})," service"]}),"\n",(0,t.jsxs)(n.li,{children:["on both sides, you'll be warned if the ports don't match, and the ",(0,t.jsx)(n.code,{children:"IngressRoute"})," service port is used"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Thus, in case of two sides port definition, Mesh expects a match between ports."}),"\n",(0,t.jsx)(n.p,{children:'??? example "Examples"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test.route\n  namespace: default\n\nspec:\n  entryPoints:\n    - foo\n\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: external-svc\n      port: 80\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: default\nspec:\n  externalName: external.domain\n  type: ExternalName\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="ExternalName Service"',children:"---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test.route\n  namespace: default\n\nspec:\n  entryPoints:\n    - foo\n\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: external-svc\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: default\nspec:\n  externalName: external.domain\n  type: ExternalName\n  ports:\n    - port: 80\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Both sides"',children:"---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test.route\n  namespace: default\n\nspec:\n  entryPoints:\n    - foo\n\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: external-svc\n      port: 80\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: default\nspec:\n  externalName: external.domain\n  type: ExternalName\n  ports:\n    - port: 80\n"})}),"\n",(0,t.jsx)(n.h4,{id:"load-balancing",children:"Load Balancing"}),"\n",(0,t.jsxs)(n.p,{children:["More information in the dedicated server ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/services/#load-balancing-strategy",children:"load balancing"})," section."]}),"\n",(0,t.jsx)(n.p,{children:'!!! info "Declaring and using Kubernetes Service Load Balancing"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: ingressroutebar\n  namespace: default\n\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: Host(`example.com`) && PathPrefix(`/foo`)\n    kind: Rule\n    services:\n    - name: svc1\n      namespace: default\n    - name: svc2\n      namespace: default\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="K8s Service"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: svc1\n  namespace: default\n\nspec:\n  ports:\n    - name: http\n      port: 80\n  selector:\n    app: Meshlabs\n    task: app1\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: svc2\n  namespace: default\n\nspec:\n  ports:\n    - name: http\n      port: 80\n  selector:\n    app: Meshlabs\n    task: app2\n"})}),"\n",(0,t.jsx)(n.p,{children:'!!! important "Kubernetes Service Native Load-Balancing"'}),"\n",(0,t.jsxs)(n.p,{children:["To avoid creating the server load-balancer with the pods IPs and use Kubernetes Service clusterIP directly,\none should set the service ",(0,t.jsx)(n.code,{children:"NativeLB"})," option to true.\nPlease note that, by default, Mesh reuses the established connections to the backends for performance purposes. This can prevent the requests load balancing between the replicas from behaving as one would expect when the option is set.\nBy default, ",(0,t.jsx)(n.code,{children:"NativeLB"})," is false."]}),"\n",(0,t.jsx)(n.p,{children:'??? example "Example"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test.route\n  namespace: default\n\nspec:\n  entryPoints:\n    - foo\n\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: svc\n      port: 80\n      # Here, nativeLB instructs to build the servers load balancer with the Kubernetes Service clusterIP only.\n      nativeLB: true\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: svc\n  namespace: default\nspec:\n  type: ClusterIP\n  ...\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"kind-middleware",children:["Kind: ",(0,t.jsx)(n.code,{children:"Middleware"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Middleware"})," is the CRD implementation of a ",(0,t.jsx)(n.a,{href:"/doc/docs/middlewares/http/overview",children:"Mesh middleware"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Register the ",(0,t.jsx)(n.code,{children:"Middleware"})," ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/dynamic-configuration/kubernetes-crd#definitions",children:"kind"})," in the Kubernetes cluster before creating ",(0,t.jsx)(n.code,{children:"Middleware"})," objects or referencing middlewares in the ",(0,t.jsx)(n.a,{href:"#kind-ingressroute",children:(0,t.jsx)(n.code,{children:"IngressRoute"})})," objects."]}),"\n",(0,t.jsx)(n.p,{children:'??? "Declaring and Referencing a Middleware"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Middleware"',children:"apiVersion: Mesh.io/v1alpha1\nkind: Middleware\nmetadata:\n  name: stripprefix\n  namespace: foo\n\nspec:\n  stripPrefix:\n    prefixes:\n      - /stripit\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: ingressroutebar\n\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: Host(`example.com`) && PathPrefix(`/stripit`)\n    kind: Rule\n    services:\n    - name: whoami\n      port: 80\n    middlewares:\n    - name: stripprefix\n      namespace: foo\n"})}),"\n",(0,t.jsx)(n.p,{children:'!!! important "Cross-provider namespace"'}),"\n",(0,t.jsxs)(n.p,{children:["As Kubernetes also has its own notion of namespace, one should not confuse the kubernetes namespace of a resource\n(in the reference to the middleware) with the ",(0,t.jsx)(n.a,{href:"/doc/docs/providers/overview#provider-namespace",children:"provider namespace"}),",\nwhen the definition of the middleware comes from another provider.\nIn this context, specifying a namespace when referring to the resource does not make any sense, and will be ignored.\nAdditionally, when you want to reference a Middleware from the CRD Provider,\nyou have to append the namespace of the resource in the resource-name as Mesh appends the namespace internally automatically."]}),"\n",(0,t.jsxs)(n.p,{children:["More information about available middlewares in the dedicated ",(0,t.jsx)(n.a,{href:"/doc/docs/middlewares/http/overview",children:"middlewares section"}),"."]}),"\n",(0,t.jsxs)(n.h3,{id:"kind-meshservice",children:["Kind: ",(0,t.jsx)(n.code,{children:"MeshService"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"MeshService"})," is the CRD implementation of a ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/services/",children:'"Mesh Service"'}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Register the ",(0,t.jsx)(n.code,{children:"MeshService"})," ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/dynamic-configuration/kubernetes-crd#definitions",children:"kind"})," in the Kubernetes cluster before creating ",(0,t.jsx)(n.code,{children:"MeshService"})," objects,\nreferencing services in the ",(0,t.jsx)(n.a,{href:"#kind-ingressroute",children:(0,t.jsx)(n.code,{children:"IngressRoute"})})," objects, or recursively in others ",(0,t.jsx)(n.code,{children:"MeshService"})," objects."]}),"\n",(0,t.jsx)(n.p,{children:'!!! info "Disambiguate Mesh and Kubernetes Services"'}),"\n",(0,t.jsxs)(n.p,{children:["As the field ",(0,t.jsx)(n.code,{children:"name"})," can reference different types of objects, use the field ",(0,t.jsx)(n.code,{children:"kind"})," to avoid any ambiguity."]}),"\n",(0,t.jsxs)(n.p,{children:["The field ",(0,t.jsx)(n.code,{children:"kind"})," allows the following values:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"Service"})," (default value): to reference a ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes Service"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"MeshService"}),": to reference another ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/services/",children:"Mesh Service"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"MeshService"})," object allows to use any (valid) combinations of:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#weighted-round-robin",children:"Weighted Round Robin"})," load balancing."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"#mirroring",children:"Mirroring"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"weighted-round-robin",children:"Weighted Round Robin"}),"\n",(0,t.jsxs)(n.p,{children:["More information in the dedicated ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/services/#weighted-round-robin-service",children:"Weighted Round Robin"})," service load balancing section."]}),"\n",(0,t.jsx)(n.p,{children:'??? "Declaring and Using Weighted Round Robin"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: ingressroutebar\n  namespace: default\n\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: Host(`example.com`) && PathPrefix(`/foo`)\n    kind: Rule\n    services:\n    - name: wrr1\n      namespace: default\n      kind: MeshService\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Weighted Round Robin"',children:"apiVersion: Mesh.io/v1alpha1\nkind: MeshService\nmetadata:\n  name: wrr1\n  namespace: default\n\nspec:\n  weighted:\n    services:\n      - name: svc1\n        port: 80\n        weight: 1\n      - name: wrr2\n        kind: MeshService\n        weight: 1\n      - name: mirror1\n        kind: MeshService\n        weight: 1\n\n---\napiVersion: Mesh.io/v1alpha1\nkind: MeshService\nmetadata:\n  name: wrr2\n  namespace: default\n\nspec:\n  weighted:\n    services:\n      - name: svc2\n        port: 80\n        weight: 1\n      - name: svc3\n        port: 80\n        weight: 1\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="K8s Service"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: svc1\n  namespace: default\n\nspec:\n  ports:\n    - name: http\n      port: 80\n  selector:\n    app: Meshlabs\n    task: app1\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: svc2\n  namespace: default\n\nspec:\n  ports:\n    - name: http\n      port: 80\n  selector:\n    app: Meshlabs\n    task: app2\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: svc3\n  namespace: default\n\nspec:\n  ports:\n    - name: http\n      port: 80\n  selector:\n    app: Meshlabs\n    task: app3\n"})}),"\n",(0,t.jsx)(n.h4,{id:"mirroring",children:"Mirroring"}),"\n",(0,t.jsxs)(n.p,{children:["More information in the dedicated ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/services/#mirroring-service",children:"mirroring"})," service section."]}),"\n",(0,t.jsx)(n.p,{children:'??? "Declaring and Using Mirroring"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: ingressroutebar\n  namespace: default\n\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: Host(`example.com`) && PathPrefix(`/foo`)\n    kind: Rule\n    services:\n    - name: mirror1\n      namespace: default\n      kind: MeshService\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Mirroring k8s Service"',children:"# Mirroring from a k8s Service\napiVersion: Mesh.io/v1alpha1\nkind: MeshService\nmetadata:\n  name: mirror1\n  namespace: default\n\nspec:\n  mirroring:\n    name: svc1                      # svc1 receives 100% of the traffic\n    port: 80\n    mirrors:\n      - name: svc2                  # svc2 receives a copy of 20% of this traffic\n        port: 80\n        percent: 20\n      - name: svc3                  # svc3 receives a copy of 15% of this traffic\n        kind: MeshService\n        percent: 15\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Mirroring Mesh Service"',children:"# Mirroring from a Mesh Service\napiVersion: Mesh.io/v1alpha1\nkind: MeshService\nmetadata:\n  name: mirror1\n  namespace: default\n\nspec:\n  mirroring:\n    name: wrr1                      # wrr1 receives 100% of the traffic\n    kind: MeshService\n    mirrors:\n      - name: svc2                  # svc2 receives a copy of 20% of this traffic\n        port: 80\n        percent: 20\n      - name: svc3                  # svc3 receives a copy of 10% of this traffic\n        kind: MeshService\n        percent: 10\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="K8s Service"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: svc1\n  namespace: default\n\nspec:\n  ports:\n    - name: http\n      port: 80\n  selector:\n    app: Meshlabs\n    task: app1\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: svc2\n  namespace: default\n\nspec:\n  ports:\n    - name: http\n      port: 80\n  selector:\n    app: Meshlabs\n    task: app2\n"})}),"\n",(0,t.jsx)(n.p,{children:'!!! important "References and namespaces"'}),"\n",(0,t.jsxs)(n.p,{children:["If the optional ",(0,t.jsx)(n.code,{children:"namespace"})," attribute is not set, the configuration will be applied with the namespace of the current resource."]}),"\n",(0,t.jsxs)(n.p,{children:["Additionally, when the definition of the ",(0,t.jsx)(n.code,{children:"MeshService"})," is from another provider,\nthe cross-provider syntax (",(0,t.jsx)(n.code,{children:"service@provider"}),") should be used to refer to the ",(0,t.jsx)(n.code,{children:"MeshService"}),", just as in the middleware case."]}),"\n",(0,t.jsxs)(n.p,{children:["Specifying a namespace attribute in this case would not make any sense, and will be ignored (except if the provider is ",(0,t.jsx)(n.code,{children:"kubernetescrd"}),")."]}),"\n",(0,t.jsx)(n.h4,{id:"stickiness-and-load-balancing",children:"Stickiness and load-balancing"}),"\n",(0,t.jsxs)(n.p,{children:["As explained in the section about ",(0,t.jsx)(n.a,{href:"../../services/#sticky-sessions",children:"Sticky sessions"}),", for stickiness to work all the way,\nit must be specified at each load-balancing level."]}),"\n",(0,t.jsxs)(n.p,{children:["When stickiness is enabled, Mesh uses Kubernetes ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/endpoint-slices/#serving",children:"serving"})," endpoints status to detect and mark servers as fenced.\nFenced servers can still process requests tied to sticky cookies, while they are terminating."]}),"\n",(0,t.jsxs)(n.p,{children:["For instance, in the example below, there is a first level of load-balancing because there is a (Weighted Round Robin) load-balancing of the two ",(0,t.jsx)(n.code,{children:"whoami"})," services,\nand there is a second level because each whoami service is a ",(0,t.jsx)(n.code,{children:"replicaset"})," and is thus handled as a load-balancer of servers."]}),"\n",(0,t.jsx)(n.p,{children:'??? "Stickiness on two load-balancing levels"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: ingressroutebar\n  namespace: default\n\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: Host(`example.com`) && PathPrefix(`/foo`)\n    kind: Rule\n    services:\n    - name: wrr1\n      namespace: default\n      kind: MeshService\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Weighted Round Robin"',children:"apiVersion: Mesh.io/v1alpha1\nkind: MeshService\nmetadata:\n  name: wrr1\n  namespace: default\n\nspec:\n  weighted:\n    services:\n      - name: whoami1\n        kind: Service\n        port: 80\n        weight: 1\n        sticky:\n          cookie:\n            name: lvl2\n      - name: whoami2\n        kind: Service\n        weight: 1\n        port: 80\n        sticky:\n          cookie:\n            name: lvl2\n    sticky:\n      cookie:\n        name: lvl1\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="K8s Service"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: whoami1\n\nspec:\n  ports:\n    - protocol: TCP\n      name: web\n      port: 80\n  selector:\n    app: whoami1\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: whoami2\n\nspec:\n  ports:\n    - protocol: TCP\n      name: web\n      port: 80\n  selector:\n    app: whoami2\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Deployment (to illustrate replicas)"',children:"kind: Deployment\napiVersion: apps/v1\nmetadata:\n  namespace: default\n  name: whoami1\n  labels:\n    app: whoami1\n\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: whoami1\n  template:\n    metadata:\n      labels:\n        app: whoami1\n    spec:\n      containers:\n        - name: whoami1\n          image: Mesh/whoami\n          ports:\n            - name: web\n              containerPort: 80\n\n---\nkind: Deployment\napiVersion: apps/v1\nmetadata:\n  namespace: default\n  name: whoami2\n  labels:\n    app: whoami2\n\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: whoami2\n  template:\n    metadata:\n      labels:\n        app: whoami2\n    spec:\n      containers:\n        - name: whoami2\n          image: Mesh/whoami\n          ports:\n            - name: web\n              containerPort: 80\n"})}),"\n",(0,t.jsx)(n.p,{children:"To keep a session open with the same server, the client would then need to specify the two levels within the cookie for each request, e.g. with curl:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'curl -H Host:example.com -b "lvl1=default-whoami1-80; lvl2=http://10.42.0.6:80" http://localhost:8000/foo\n'})}),"\n",(0,t.jsxs)(n.p,{children:["assuming ",(0,t.jsx)(n.code,{children:"10.42.0.6"})," is the IP address of one of the replicas (a pod then) of the ",(0,t.jsx)(n.code,{children:"whoami1"})," service."]}),"\n",(0,t.jsxs)(n.h3,{id:"kind-ingressroutetcp",children:["Kind: ",(0,t.jsx)(n.code,{children:"IngressRouteTCP"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"IngressRouteTCP"})," is the CRD implementation of a ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#configuring-tcp-routers",children:"Mesh TCP router"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Register the ",(0,t.jsx)(n.code,{children:"IngressRouteTCP"})," ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/dynamic-configuration/kubernetes-crd#definitions",children:"kind"})," in the Kubernetes cluster before creating ",(0,t.jsx)(n.code,{children:"IngressRouteTCP"})," objects."]}),"\n",(0,t.jsx)(n.p,{children:'!!! info "IngressRouteTCP Attributes"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRouteTCP\nmetadata:\n  name: ingressroutetcpfoo\n\nspec:\n  entryPoints:                    # [1]\n    - footcp\n  routes:                         # [2]\n  - match: HostSNI(`*`)           # [3]\n    priority: 10                  # [4]\n    middlewares:\n    - name: middleware1           # [5]\n      namespace: default          # [6]\n    services:                     # [7]\n    - name: foo                   # [8]\n      port: 8080                  # [9]\n      weight: 10                  # [10]\n      proxyProtocol:              # [11]\n        version: 1                # [12]\n      serversTransport: transport # [13]\n      nativeLB: true              # [14]\n      nodePortLB: true            # [15]\n      tls: false                  # [16]\n\n  tls:                            # [17]\n    secretName: supersecret       # [18]\n    options:                      # [19]\n      name: opt                   # [20]\n      namespace: default          # [21]\n    certResolver: foo             # [22]\n    domains:                      # [23]\n    - main: example.net           # [24]\n      sans:                       # [25]\n      - a.example.net\n      - b.example.net\n    passthrough: false            # [26]\n"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Ref"}),(0,t.jsx)(n.th,{children:"Attribute"}),(0,t.jsx)(n.th,{children:"Purpose"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[1]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"entryPoints"})}),(0,t.jsxs)(n.td,{children:["List of ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#entrypoints_1",children:"entrypoints"})," names"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[2]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes"})}),(0,t.jsx)(n.td,{children:"List of routes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[3]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].match"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#rule_1",children:"rule"})," of the underlying router"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[4]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].priority"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#priority_1",children:"priority"})," to disambiguate rules of the same length, for route matching"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[5]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"middlewares[n].name"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"#kind-middlewaretcp",children:"MiddlewareTCP"})," name"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[6]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"middlewares[n].namespace"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"#kind-middlewaretcp",children:"MiddlewareTCP"})," namespace"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[7]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].services"})}),(0,t.jsxs)(n.td,{children:["List of ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," definitions  (See below for ",(0,t.jsx)(n.code,{children:"ExternalName Service"})," setup)"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[8]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].name"})}),(0,t.jsxs)(n.td,{children:["Defines the name of a ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[9]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].port"})}),(0,t.jsxs)(n.td,{children:["Defines the port of a ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"}),". This can be a reference to a named port."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[10]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].weight"})}),(0,t.jsx)(n.td,{children:"Defines the weight to apply to the server load balancing"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[11]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].proxyProtocol"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/services/#proxy-protocol",children:"PROXY protocol"})," configuration"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[12]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].proxyProtocol.version"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/services/#proxy-protocol",children:"PROXY protocol"})," version"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[13]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].serversTransport"})}),(0,t.jsxs)(n.td,{children:["Defines the reference to a ",(0,t.jsx)(n.a,{href:"#kind-serverstransporttcp",children:"ServersTransportTCP"}),". The ServersTransport namespace is assumed to be the ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," namespace (see ",(0,t.jsx)(n.a,{href:"#serverstransport-reference",children:"ServersTransport reference"}),")."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[14]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].nativeLB"})}),(0,t.jsx)(n.td,{children:"Controls, when creating the load-balancer, whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[15]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].nodePortLB"})}),(0,t.jsx)(n.td,{children:"Controls, when creating the load-balancer, whether the LB's children are directly the nodes internal IPs when the service type is of type NodePort."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[16]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].tls"})}),(0,t.jsx)(n.td,{children:"Defines whether to use TLS when dialing with the target service."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[17]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls"})}),(0,t.jsxs)(n.td,{children:["Defines ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#tls_1",children:"TLS"})," certificate configuration"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[18]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.secretName"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/configuration/secret/",children:"secret"})," name used to store the certificate (in the ",(0,t.jsx)(n.code,{children:"IngressRoute"})," namespace)"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[19]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.options"})}),(0,t.jsxs)(n.td,{children:["Defines the reference to a ",(0,t.jsx)(n.a,{href:"#kind-tlsoption",children:"TLSOption"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[20]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.options.name"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"#kind-tlsoption",children:"TLSOption"})," name"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[21]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.options.namespace"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"#kind-tlsoption",children:"TLSOption"})," namespace"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[22]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.certResolver"})}),(0,t.jsxs)(n.td,{children:["Defines the reference to a ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#certresolver_1",children:"CertResolver"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[23]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.domains"})}),(0,t.jsxs)(n.td,{children:["List of ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#domains_1",children:"domains"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[24]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.domains[n].main"})}),(0,t.jsx)(n.td,{children:"Defines the main domain name"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[25]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.domains[n].sans"})}),(0,t.jsx)(n.td,{children:"List of SANs (alternative domains)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[26]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.passthrough"})}),(0,t.jsxs)(n.td,{children:["If ",(0,t.jsx)(n.code,{children:"true"}),", delegates the TLS termination to the backend"]})]})]})]}),"\n",(0,t.jsx)(n.p,{children:'??? example "Declaring an IngressRouteTCP"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRouteTCP"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRouteTCP\nmetadata:\n  name: ingressroutetcpfoo\n\nspec:\n  entryPoints:\n    - footcp\n  routes:\n  # Match is the rule corresponding to an underlying router.\n  - match: HostSNI(`*`)\n    priority: 10\n    services:\n    - name: foo\n      port: 8080\n      weight: 10\n    - name: bar\n      port: 8081\n      weight: 10\n  tls:\n    certResolver: foo\n    domains:\n    - main: example.net\n      sans:\n      - a.example.net\n      - b.example.net\n    options:\n      name: opt\n      namespace: default\n    secretName: supersecret\n    passthrough: false\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="TLSOption"',children:"apiVersion: Mesh.io/v1alpha1\nkind: TLSOption\nmetadata:\n  name: opt\n  namespace: default\n\nspec:\n  minVersion: VersionTLS12\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Secret"',children:"apiVersion: v1\nkind: Secret\nmetadata:\n  name: supersecret\n\ndata:\n  tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0=\n  tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0=\n"})}),"\n",(0,t.jsx)(n.p,{children:'!!! important "Using Kubernetes ExternalName Service"'}),"\n",(0,t.jsxs)(n.p,{children:["Mesh backends creation needs a port to be set, however Kubernetes ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/#externalname",children:"ExternalName Service"})," could be defined without any port.\nAccordingly, Mesh supports defining a port in two ways:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["only on ",(0,t.jsx)(n.code,{children:"IngressRouteTCP"})," service"]}),"\n",(0,t.jsxs)(n.li,{children:["on both sides, you'll be warned if the ports don't match, and the ",(0,t.jsx)(n.code,{children:"IngressRouteTCP"})," service port is used"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Thus, in case of two sides port definition, Mesh expects a match between ports."}),"\n",(0,t.jsx)(n.p,{children:'??? example "Examples"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Only on IngressRouteTCP"',children:"---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRouteTCP\nmetadata:\n  name: test.route\n  namespace: default\n\nspec:\n  entryPoints:\n    - foo\n\n  routes:\n  - match: HostSNI(`*`)\n    services:\n    - name: external-svc\n      port: 80\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: default\nspec:\n  externalName: external.domain\n  type: ExternalName\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="On both sides"',children:"---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRouteTCP\nmetadata:\n  name: test.route\n  namespace: default\n\nspec:\n  entryPoints:\n    - foo\n\n  routes:\n  - match: HostSNI(`*`)\n    services:\n    - name: external-svc\n      port: 80\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: default\nspec:\n  externalName: external.domain\n  type: ExternalName\n  ports:\n    - port: 80\n"})}),"\n",(0,t.jsx)(n.p,{children:'!!! important "Kubernetes Service Native Load-Balancing"'}),"\n",(0,t.jsxs)(n.p,{children:["To avoid creating the server load-balancer with the pods IPs and use Kubernetes Service clusterIP directly,\none should set the TCP service ",(0,t.jsx)(n.code,{children:"NativeLB"})," option to true.\nBy default, ",(0,t.jsx)(n.code,{children:"NativeLB"})," is false."]}),"\n",(0,t.jsx)(n.p,{children:'??? example "Examples"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRouteTCP\nmetadata:\n  name: test.route\n  namespace: default\n\nspec:\n  entryPoints:\n    - foo\n\n  routes:\n  - match: HostSNI(`*`)\n    services:\n    - name: svc\n      port: 80\n      # Here, nativeLB instructs to build the servers load balancer with the Kubernetes Service clusterIP only.\n      nativeLB: true\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: svc\n  namespace: default\nspec:\n  type: ClusterIP\n  ...\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"kind-middlewaretcp",children:["Kind: ",(0,t.jsx)(n.code,{children:"MiddlewareTCP"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"MiddlewareTCP"})," is the CRD implementation of a ",(0,t.jsx)(n.a,{href:"/doc/docs/middlewares/tcp/overview",children:"Mesh TCP middleware"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Register the ",(0,t.jsx)(n.code,{children:"MiddlewareTCP"})," ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/dynamic-configuration/kubernetes-crd#definitions",children:"kind"})," in the Kubernetes cluster before creating ",(0,t.jsx)(n.code,{children:"MiddlewareTCP"})," objects or referencing TCP middlewares in the ",(0,t.jsx)(n.a,{href:"#kind-ingressroutetcp",children:(0,t.jsx)(n.code,{children:"IngressRouteTCP"})})," objects."]}),"\n",(0,t.jsx)(n.p,{children:'??? "Declaring and Referencing a MiddlewareTCP "'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Middleware"',children:"apiVersion: Mesh.io/v1alpha1\nkind: MiddlewareTCP\nmetadata:\n  name: ipallowlist\nspec:\n  ipAllowList:\n    sourceRange:\n      - 127.0.0.1/32\n      - 192.168.1.7\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: ingressroutebar\n\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: Host(`example.com`) && PathPrefix(`/allowlist`)\n    kind: Rule\n    services:\n    - name: whoami\n      port: 80\n    middlewares:\n    - name: ipallowlist\n      namespace: foo\n"})}),"\n",(0,t.jsx)(n.p,{children:'!!! important "Cross-provider namespace"'}),"\n",(0,t.jsxs)(n.p,{children:["As Kubernetes also has its own notion of namespace, one should not confuse the kubernetes namespace of a resource\n(in the reference to the middleware) with the ",(0,t.jsx)(n.a,{href:"/doc/docs/providers/overview#provider-namespace",children:"provider namespace"}),",\nwhen the definition of the TCP middleware comes from another provider.\nIn this context, specifying a namespace when referring to the resource does not make any sense, and will be ignored.\nAdditionally, when you want to reference a MiddlewareTCP from the CRD Provider,\nyou have to append the namespace of the resource in the resource-name as Mesh appends the namespace internally automatically."]}),"\n",(0,t.jsxs)(n.p,{children:["More information about available TCP middlewares in the dedicated ",(0,t.jsx)(n.a,{href:"/doc/docs/middlewares/tcp/overview",children:"middlewares section"}),"."]}),"\n",(0,t.jsxs)(n.h3,{id:"kind-ingressrouteudp",children:["Kind: ",(0,t.jsx)(n.code,{children:"IngressRouteUDP"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"IngressRouteUDP"})," is the CRD implementation of a ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#configuring-udp-routers",children:"Mesh UDP router"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Register the ",(0,t.jsx)(n.code,{children:"IngressRouteUDP"})," ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/dynamic-configuration/kubernetes-crd#definitions",children:"kind"})," in the Kubernetes cluster before creating ",(0,t.jsx)(n.code,{children:"IngressRouteUDP"})," objects."]}),"\n",(0,t.jsx)(n.p,{children:'!!! info "IngressRouteUDP Attributes"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRouteUDP\nmetadata:\n  name: ingressrouteudpfoo\n\nspec:\n  entryPoints:                  # [1]\n    - fooudp\n  routes:                       # [2]\n  - services:                   # [3]\n    - name: foo                 # [4]\n      port: 8080                # [5]\n      weight: 10                # [6]\n      nativeLB: true            # [7]\n      nodePortLB: true          # [8]\n"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Ref"}),(0,t.jsx)(n.th,{children:"Attribute"}),(0,t.jsx)(n.th,{children:"Purpose"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[1]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"entryPoints"})}),(0,t.jsxs)(n.td,{children:["List of ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/routers/#entrypoints_1",children:"entrypoints"})," names"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[2]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes"})}),(0,t.jsx)(n.td,{children:"List of routes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[3]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].services"})}),(0,t.jsxs)(n.td,{children:["List of ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," definitions (See below for ",(0,t.jsx)(n.code,{children:"ExternalName Service"})," setup)"]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[4]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].name"})}),(0,t.jsxs)(n.td,{children:["Defines the name of a ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[5]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].port"})}),(0,t.jsxs)(n.td,{children:["Defines the port of a ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"}),". This can be a reference to a named port."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[6]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].weight"})}),(0,t.jsx)(n.td,{children:"Defines the weight to apply to the server load balancing"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[7]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].nativeLB"})}),(0,t.jsx)(n.td,{children:"Controls, when creating the load-balancer, whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[8]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"services[n].nodePortLB"})}),(0,t.jsx)(n.td,{children:"Controls, when creating the load-balancer, whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is NodePort."})]})]})]}),"\n",(0,t.jsx)(n.p,{children:'??? example "Declaring an IngressRouteUDP"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRouteUDP\nmetadata:\n  name: ingressrouteudpfoo\n\nspec:\n  entryPoints:\n    - fooudp\n  routes:\n  - services:\n    - name: foo\n      port: 8080\n      weight: 10\n    - name: bar\n      port: 8081\n      weight: 10\n"})}),"\n",(0,t.jsx)(n.p,{children:'!!! important "Using Kubernetes ExternalName Service"'}),"\n",(0,t.jsxs)(n.p,{children:["Mesh backends creation needs a port to be set, however Kubernetes ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/#externalname",children:"ExternalName Service"})," could be defined without any port.\nAccordingly, Mesh supports defining a port in two ways:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["only on ",(0,t.jsx)(n.code,{children:"IngressRouteUDP"})," service"]}),"\n",(0,t.jsxs)(n.li,{children:["on both sides, you'll be warned if the ports don't match, and the ",(0,t.jsx)(n.code,{children:"IngressRouteUDP"})," service port is used"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Thus, in case of two sides port definition, Mesh expects a match between ports."}),"\n",(0,t.jsx)(n.p,{children:'??? example "Examples"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRouteUDP"',children:"---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRouteUDP\nmetadata:\n  name: test.route\n  namespace: default\n\nspec:\n  entryPoints:\n    - foo\n\n  routes:\n  - services:\n    - name: external-svc\n      port: 80\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: default\nspec:\n  externalName: external.domain\n  type: ExternalName\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="ExternalName Service"',children:"---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRouteUDP\nmetadata:\n  name: test.route\n  namespace: default\n\nspec:\n  entryPoints:\n    - foo\n\n  routes:\n  - services:\n    - name: external-svc\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: default\nspec:\n  externalName: external.domain\n  type: ExternalName\n  ports:\n    - port: 80\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Both sides"',children:"---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRouteUDP\nmetadata:\n  name: test.route\n  namespace: default\n\nspec:\n  entryPoints:\n    - foo\n\n  routes:\n  - services:\n    - name: external-svc\n      port: 80\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: default\nspec:\n  externalName: external.domain\n  type: ExternalName\n  ports:\n    - port: 80\n"})}),"\n",(0,t.jsx)(n.p,{children:'!!! important "Kubernetes Service Native Load-Balancing"'}),"\n",(0,t.jsxs)(n.p,{children:["To avoid creating the server load-balancer with the pods IPs and use Kubernetes Service clusterIP directly,\none should set the UDP service ",(0,t.jsx)(n.code,{children:"NativeLB"})," option to true.\nBy default, ",(0,t.jsx)(n.code,{children:"NativeLB"})," is false."]}),"\n",(0,t.jsx)(n.p,{children:'??? example "Example"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRouteUDP\nmetadata:\n  name: test.route\n  namespace: default\n\nspec:\n  entryPoints:\n    - foo\n\n  routes:\n  - services:\n    - name: svc\n      port: 80\n      # Here, nativeLB instructs to build the servers load balancer with the Kubernetes Service clusterIP only.\n      nativeLB: true\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: svc\n  namespace: default\nspec:\n  type: ClusterIP\n  ...\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"kind-tlsoption",children:["Kind: ",(0,t.jsx)(n.code,{children:"TLSOption"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"TLSOption"})," is the CRD implementation of a ",(0,t.jsx)(n.a,{href:"/doc/docs/https/tls#tls-options",children:'Mesh "TLS Option"'}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Register the ",(0,t.jsx)(n.code,{children:"TLSOption"})," ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/dynamic-configuration/kubernetes-crd#definitions",children:"kind"})," in the Kubernetes cluster before creating ",(0,t.jsx)(n.code,{children:"TLSOption"})," objects\nor referencing TLS options in the ",(0,t.jsx)(n.a,{href:"#kind-ingressroute",children:(0,t.jsx)(n.code,{children:"IngressRoute"})})," / ",(0,t.jsx)(n.a,{href:"#kind-ingressroutetcp",children:(0,t.jsx)(n.code,{children:"IngressRouteTCP"})})," objects."]}),"\n",(0,t.jsx)(n.p,{children:'!!! info "TLSOption Attributes"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="TLSOption"',children:"apiVersion: Mesh.io/v1alpha1\nkind: TLSOption\nmetadata:\n  name: mytlsoption                             # [1]\n  namespace: default\n\nspec:\n  minVersion: VersionTLS12                      # [2]\n  maxVersion: VersionTLS13                      # [3]\n  curvePreferences:                             # [4]\n    - CurveP521\n    - CurveP384\n  cipherSuites:                                 # [5]\n    - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n    - TLS_RSA_WITH_AES_256_GCM_SHA384\n  clientAuth:                                   # [6]\n    secretNames:                                # [7]\n      - secret-ca1\n      - secret-ca2\n    clientAuthType: VerifyClientCertIfGiven     # [8]\n  sniStrict: true                               # [9]\n  alpnProtocols:                                # [10]\n    - foobar\n"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Ref"}),(0,t.jsx)(n.th,{children:"Attribute"}),(0,t.jsx)(n.th,{children:"Purpose"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[1]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"name"})}),(0,t.jsxs)(n.td,{children:["Defines the name of the TLSOption resource. One can use ",(0,t.jsx)(n.code,{children:"default"})," as name to redefine the ",(0,t.jsx)(n.a,{href:"/doc/docs/https/tls#tls-options",children:"default TLSOption"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[2]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"minVersion"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/https/tls#minimum-tls-version",children:"minimum TLS version"})," that is acceptable."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[3]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"maxVersion"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/https/tls#maximum-tls-version",children:"maximum TLS version"})," that is acceptable."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[4]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"cipherSuites"})}),(0,t.jsxs)(n.td,{children:["list of supported ",(0,t.jsx)(n.a,{href:"/doc/docs/https/tls#cipher-suites",children:"cipher suites"})," for TLS versions up to TLS 1.2."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[5]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"curvePreferences"})}),(0,t.jsxs)(n.td,{children:["List of the ",(0,t.jsx)(n.a,{href:"/doc/docs/https/tls#curve-preferences",children:"elliptic curves references"})," that will be used in an ECDHE handshake, in preference order."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[6]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"clientAuth"})}),(0,t.jsxs)(n.td,{children:["determines the server's policy for TLS ",(0,t.jsx)(n.a,{href:"/doc/docs/https/tls#client-authentication-mtls",children:"Client Authentication"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[7]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"clientAuth.secretNames"})}),(0,t.jsxs)(n.td,{children:["list of names of the referenced Kubernetes ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/configuration/secret/",children:"Secrets"})," (in TLSOption namespace). The secret must contain a certificate under either a ",(0,t.jsx)(n.code,{children:"tls.ca"})," or a ",(0,t.jsx)(n.code,{children:"ca.crt"})," key."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[8]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"clientAuth.clientAuthType"})}),(0,t.jsxs)(n.td,{children:["defines the client authentication type to apply. The available values are: ",(0,t.jsx)(n.code,{children:"NoClientCert"}),", ",(0,t.jsx)(n.code,{children:"RequestClientCert"}),", ",(0,t.jsx)(n.code,{children:"VerifyClientCertIfGiven"})," and ",(0,t.jsx)(n.code,{children:"RequireAndVerifyClientCert"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[9]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"sniStrict"})}),(0,t.jsxs)(n.td,{children:["if ",(0,t.jsx)(n.code,{children:"true"}),", Mesh won't allow connections from clients connections that do not specify a server_name extension."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[10]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"alpnProtocols"})}),(0,t.jsxs)(n.td,{children:["List of supported ",(0,t.jsx)(n.a,{href:"/doc/docs/https/tls#alpn-protocols",children:"application level protocols"})," for the TLS handshake, in order of preference."]})]})]})]}),"\n",(0,t.jsx)(n.p,{children:'!!! info "CA Secret"'}),"\n",(0,t.jsxs)(n.p,{children:["The CA secret must contain a base64 encoded certificate under either a ",(0,t.jsx)(n.code,{children:"tls.ca"})," or a ",(0,t.jsx)(n.code,{children:"ca.crt"})," key."]}),"\n",(0,t.jsx)(n.p,{children:'??? example "Declaring and referencing a TLSOption"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="TLSOption"',children:"apiVersion: Mesh.io/v1alpha1\nkind: TLSOption\nmetadata:\n  name: mytlsoption\n  namespace: default\n\nspec:\n  minVersion: VersionTLS12\n  sniStrict: true\n  cipherSuites:\n    - TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256\n    - TLS_RSA_WITH_AES_256_GCM_SHA384\n  clientAuth:\n    secretNames:\n      - secret-ca1\n      - secret-ca2\n    clientAuthType: VerifyClientCertIfGiven\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: ingressroutebar\n\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: Host(`example.com`) && PathPrefix(`/stripit`)\n    kind: Rule\n    services:\n    - name: whoami\n      port: 80\n  tls:\n    options: \n      name: mytlsoption\n      namespace: default\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Secrets"',children:"apiVersion: v1\nkind: Secret\nmetadata:\n  name: secret-ca1\n  namespace: default\n\ndata:\n  # Must contain a certificate under either a `tls.ca` or a `ca.crt` key.\n  tls.ca: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0=\n\n---\napiVersion: v1\nkind: Secret\nmetadata:\n  name: secret-ca2\n  namespace: default\n\ndata:\n  # Must contain a certificate under either a `tls.ca` or a `ca.crt` key. \n  tls.ca: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0=\n"})}),"\n",(0,t.jsx)(n.p,{children:'!!! important "References and namespaces"'}),"\n",(0,t.jsxs)(n.p,{children:["If the optional ",(0,t.jsx)(n.code,{children:"namespace"})," attribute is not set, the configuration will be applied with the namespace of the IngressRoute."]}),"\n",(0,t.jsxs)(n.p,{children:["Additionally, when the definition of the TLS option is from another provider,\nthe cross-provider ",(0,t.jsx)(n.a,{href:"/doc/docs/providers/overview#provider-namespace",children:"syntax"})," (",(0,t.jsx)(n.code,{children:"middlewarename@provider"}),") should be used to refer to the TLS option.\nSpecifying a namespace attribute in this case would not make any sense, and will be ignored."]}),"\n",(0,t.jsxs)(n.h3,{id:"kind-tlsstore",children:["Kind: ",(0,t.jsx)(n.code,{children:"TLSStore"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"TLSStore"})," is the CRD implementation of a ",(0,t.jsx)(n.a,{href:"/doc/docs/https/tls#certificates-stores",children:'Mesh "TLS Store"'}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Register the ",(0,t.jsx)(n.code,{children:"TLSStore"})," kind in the Kubernetes cluster before creating ",(0,t.jsx)(n.code,{children:"TLSStore"})," objects."]}),"\n",(0,t.jsx)(n.p,{children:'!!! important "Default TLS Store"'}),"\n",(0,t.jsxs)(n.p,{children:["Mesh currently only uses the ",(0,t.jsx)(n.a,{href:"/doc/docs/https/tls#certificates-stores",children:'TLS Store named "default"'}),".\nThis ",(0,t.jsx)(n.em,{children:"default"})," ",(0,t.jsx)(n.code,{children:"TLSStore"})," should be in a namespace discoverable by Mesh. Since it is used by default on ",(0,t.jsx)(n.a,{href:"#kind-ingressroute",children:(0,t.jsx)(n.code,{children:"IngressRoute"})})," and ",(0,t.jsx)(n.a,{href:"#kind-ingressroutetcp",children:(0,t.jsx)(n.code,{children:"IngressRouteTCP"})})," objects, there never is a need to actually reference it.\nThis means that you cannot have two stores that are named default in different Kubernetes namespaces.\nAs a consequence, with respect to TLS stores, the only change that makes sense (and only if needed) is to configure the default TLSStore."]}),"\n",(0,t.jsx)(n.p,{children:'!!! info "TLSStore Attributes"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="TLSStore"',children:"apiVersion: Mesh.io/v1alpha1\nkind: TLSStore\nmetadata:\n  name: default\n\nspec:\n  certificates:                            # [1]\n    - secretName: foo                      \n    - secretName: bar\n  defaultCertificate:                      # [2]\n    secretName: secret                     \n"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Ref"}),(0,t.jsx)(n.th,{children:"Attribute"}),(0,t.jsx)(n.th,{children:"Purpose"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[1]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"certificates"})}),(0,t.jsxs)(n.td,{children:["List of Kubernetes ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/configuration/secret/",children:"Secrets"}),", each of them holding a key/certificate pair to add to the store."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[2]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"defaultCertificate"})}),(0,t.jsxs)(n.td,{children:["Name of a Kubernetes ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/configuration/secret/",children:"Secret"})," that holds the default key/certificate pair for the store."]})]})]})]}),"\n",(0,t.jsx)(n.p,{children:'??? example "Declaring and referencing a TLSStore"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="TLSStore"',children:"apiVersion: Mesh.io/v1alpha1\nkind: TLSStore\nmetadata:\n  name: default\n\nspec:\n  defaultCertificate:\n    secretName:  supersecret\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: ingressroutebar\n\nspec:\n  entryPoints:\n    - websecure\n  routes:\n  - match: Host(`example.com`) && PathPrefix(`/stripit`)\n    kind: Rule\n    services:\n    - name: whoami\n      port: 80\n  tls: {}\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Secret"',children:"apiVersion: v1\nkind: Secret\nmetadata:\n  name: supersecret\n\ndata:\n  tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0=\n  tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0=\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"kind-serverstransport",children:["Kind: ",(0,t.jsx)(n.code,{children:"ServersTransport"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ServersTransport"})," is the CRD implementation of a ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/services/#serverstransport",children:"ServersTransport"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:['!!! important "Default serversTransport"\nIf no ',(0,t.jsx)(n.code,{children:"serversTransport"})," is specified, the ",(0,t.jsx)(n.code,{children:"default@internal"})," will be used.\nThe ",(0,t.jsx)(n.code,{children:"default@internal"})," serversTransport is created from the ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/overview#http-servers-transports",children:"static configuration"}),"."]}),"\n",(0,t.jsx)(n.p,{children:'!!! info "ServersTransport Attributes"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="ServersTransport"',children:'apiVersion: Mesh.io/v1alpha1\nkind: ServersTransport\nmetadata:\n  name: mytransport\n  namespace: default\n\nspec:\n  serverName: foobar                        # [1]\n  insecureSkipVerify: true                  # [2]\n  rootCAs:                                  # [3]\n    - configMap: foobar\n    - secret: foobar\n  certificatesSecrets:                      # [4]\n    - foobar\n    - foobar\n  maxIdleConnsPerHost: 1                    # [5]\n  forwardingTimeouts:                       # [6]\n    dialTimeout: 42s                        # [7]\n    responseHeaderTimeout: 42s              # [8]\n    idleConnTimeout: 42s                    # [9]\n  peerCertURI: foobar                       # [10]\n  disableHTTP2: true                        # [11]\n  spiffe:                                   # [12] \n    ids:                                    # [13]\n    - spiffe://trust-domain/id1\n    - spiffe://trust-domain/id2\n    trustDomain: "spiffe://trust-domain"    # [14]\n'})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Ref"}),(0,t.jsx)(n.th,{children:"Attribute"}),(0,t.jsx)(n.th,{children:"Purpose"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[1]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"serverName"})}),(0,t.jsx)(n.td,{children:"ServerName used to contact the server."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[2]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"insecureSkipVerify"})}),(0,t.jsx)(n.td,{children:"Controls whether the server's certificate chain and host name is verified."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[3]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"rootCAs"})}),(0,t.jsx)(n.td,{children:"Defines the set of root certificate authorities to use when verifying server certificates. The referenced Secret or ConfigMap must contain a certificate under either a tls.ca or a ca.crt key."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[4]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"certificatesSecrets"})}),(0,t.jsx)(n.td,{children:"Certificates to present to the server for mTLS."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[5]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"maxIdleConnsPerHost"})}),(0,t.jsxs)(n.td,{children:["Controls the maximum idle (keep-alive) connections to keep per-host. If zero, ",(0,t.jsx)(n.code,{children:"defaultMaxIdleConnsPerHost"})," is used."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[6]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"forwardingTimeouts"})}),(0,t.jsx)(n.td,{children:"Timeouts for requests forwarded to the servers."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[7]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"dialTimeout"})}),(0,t.jsx)(n.td,{children:"The amount of time to wait until a connection to a server can be established. If zero, no timeout exists."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[8]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"responseHeaderTimeout"})}),(0,t.jsx)(n.td,{children:"The amount of time to wait for a server's response headers after fully writing the request (including its body, if any). If zero, no timeout exists."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[9]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"idleConnTimeout"})}),(0,t.jsx)(n.td,{children:"The maximum amount of time an idle (keep-alive) connection will remain idle before closing itself. If zero, no timeout exists."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[10]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"peerCertURI"})}),(0,t.jsx)(n.td,{children:"URI used to match against SAN URIs during the server's certificate verification."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[11]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"disableHTTP2"})}),(0,t.jsx)(n.td,{children:"Disables HTTP/2 for connections with servers."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[12]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"spiffe"})}),(0,t.jsx)(n.td,{children:"The spiffe configuration."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[13]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ids"})}),(0,t.jsx)(n.td,{children:"Defines the allowed SPIFFE IDs (takes precedence over the SPIFFE TrustDomain)."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[14]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"trustDomain"})}),(0,t.jsx)(n.td,{children:"Defines the allowed SPIFFE trust domain."})]})]})]}),"\n",(0,t.jsx)(n.p,{children:'!!! info "CA Secret"'}),"\n",(0,t.jsxs)(n.p,{children:["The CA secret must contain a base64 encoded certificate under either a ",(0,t.jsx)(n.code,{children:"tls.ca"})," or a ",(0,t.jsx)(n.code,{children:"ca.crt"})," key."]}),"\n",(0,t.jsx)(n.p,{children:'??? example "Declaring and referencing a ServersTransport"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="ServersTransport"',children:"apiVersion: Mesh.io/v1alpha1\nkind: ServersTransport\nmetadata:\n  name: mytransport\n  namespace: default\n\nspec:\n  serverName: example.org\n  insecureSkipVerify: true\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: testroute\n  namespace: default\n\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: Host(`example.com`)\n    kind: Rule\n    services:\n    - name: whoami\n      port: 80\n      serversTransport: mytransport\n"})}),"\n",(0,t.jsx)(n.h4,{id:"serverstransport-reference",children:"ServersTransport reference"}),"\n",(0,t.jsxs)(n.p,{children:["By default, the referenced ServersTransport CRD must be defined in the same ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," namespace."]}),"\n",(0,t.jsxs)(n.p,{children:["To reference a ServersTransport CRD from another namespace,\nthe value must be of form ",(0,t.jsx)(n.code,{children:"namespace-name@kubernetescrd"}),",\nand the ",(0,t.jsx)(n.a,{href:"../../../providers/kubernetes-crd/#allowcrossnamespace",children:"allowCrossNamespace"})," option must be enabled."]}),"\n",(0,t.jsxs)(n.p,{children:["If the ServersTransport CRD is defined in another provider the cross-provider format ",(0,t.jsx)(n.code,{children:"name@provider"})," should be used."]}),"\n",(0,t.jsxs)(n.h3,{id:"kind-serverstransporttcp",children:["Kind: ",(0,t.jsx)(n.code,{children:"ServersTransportTCP"})]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ServersTransportTCP"})," is the CRD implementation of a ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/services/#serverstransport_2",children:"ServersTransportTCP"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:['!!! important "Default serversTransportTCP"\nIf no ',(0,t.jsx)(n.code,{children:"serversTransportTCP"})," is specified, the ",(0,t.jsx)(n.code,{children:"default@internal"})," will be used.\nThe ",(0,t.jsx)(n.code,{children:"default@internal"})," serversTransportTCP is created from the ",(0,t.jsx)(n.a,{href:"/doc/docs/routing/overview#tcp-servers-transports",children:"static configuration"}),"."]}),"\n",(0,t.jsx)(n.p,{children:'!!! info "ServersTransportTCP Attributes"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="ServersTransportTCP"',children:'apiVersion: Mesh.io/v1alpha1\nkind: ServersTransportTCP\nmetadata:\n  name: mytransport\n  namespace: default\n\nspec:\n  dialTimeout: 42s                          # [1]\n  dialKeepAlive: 42s                        # [2]\n  terminationDelay: 42s                     # [3]\n  tls:                                      # [4]\n    serverName: foobar                      # [5]\n    insecureSkipVerify: true                # [6]\n    peerCertURI: foobar                     # [7]\n    rootCAs:                                # [8]\n      - secret: foobar\n      - configMap: foobar\n    certificatesSecrets:                    # [9]\n      - foobar\n      - foobar\n  spiffe:                                   # [10] \n    ids:                                    # [11]\n    - spiffe://trust-domain/id1\n    - spiffe://trust-domain/id2\n    trustDomain: "spiffe://trust-domain"    # [12]\n'})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Ref"}),(0,t.jsx)(n.th,{children:"Attribute"}),(0,t.jsx)(n.th,{children:"Purpose"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[1]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"dialTimeout"})}),(0,t.jsx)(n.td,{children:"The amount of time to wait until a connection to a server can be established. If zero, no timeout exists."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[2]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"dialKeepAlive"})}),(0,t.jsx)(n.td,{children:"The interval between keep-alive probes for an active network connection. If zero, keep-alive probes are sent with a default value (currently 15 seconds), if supported by the protocol and operating system. Network protocols or operating systems that do not support keep-alives ignore this field. If negative, keep-alive probes are disabled."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[3]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"terminationDelay"})}),(0,t.jsx)(n.td,{children:"Defines the delay to wait before fully terminating the connection, after one connected peer has closed its writing capability."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[4]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls"})}),(0,t.jsx)(n.td,{children:"The TLS configuration."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[5]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"serverName"})}),(0,t.jsx)(n.td,{children:"ServerName used to contact the server."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[6]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"insecureSkipVerify"})}),(0,t.jsx)(n.td,{children:"Controls whether the server's certificate chain and host name is verified."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[7]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"peerCertURI"})}),(0,t.jsx)(n.td,{children:"URI used to match against SAN URIs during the server's certificate verification."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[8]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"rootCAs"})}),(0,t.jsx)(n.td,{children:"Defines the set of root certificate authorities to use when verifying server certificates. The referenced Secret or ConfigMap must contain a certificate under either a tls.ca or a ca.crt key."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[9]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"certificatesSecrets"})}),(0,t.jsx)(n.td,{children:"Certificates to present to the server for mTLS."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[10]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"spiffe"})}),(0,t.jsx)(n.td,{children:"The SPIFFE configuration."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[11]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ids"})}),(0,t.jsx)(n.td,{children:"Defines the allowed SPIFFE IDs (takes precedence over the SPIFFE TrustDomain)."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"[12]"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"trustDomain"})}),(0,t.jsx)(n.td,{children:"Defines the allowed SPIFFE trust domain."})]})]})]}),"\n",(0,t.jsx)(n.p,{children:'!!! info "CA Secret"'}),"\n",(0,t.jsxs)(n.p,{children:["The CA secret must contain a base64 encoded certificate under either a ",(0,t.jsx)(n.code,{children:"tls.ca"})," or a ",(0,t.jsx)(n.code,{children:"ca.crt"})," key."]}),"\n",(0,t.jsx)(n.p,{children:'??? example "Declaring and referencing a ServersTransportTCP"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="ServersTransportTCP"',children:"apiVersion: Mesh.io/v1alpha1\nkind: ServersTransportTCP\nmetadata:\n  name: mytransport\n  namespace: default\n\nspec:\n  tls:\n    serverName: example.org\n    insecureSkipVerify: true\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRouteTCP"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRouteTCP\nmetadata:\n  name: testroute\n  namespace: default\n\nspec:\n  entryPoints:\n    - tcpep\n  routes:\n  - match: HostSNI(`bar`)\n    services:\n      - name: whoamitcp\n        port: 8080\n        serversTransport: mytransport\n"})}),"\n",(0,t.jsx)(n.h4,{id:"serverstransporttcp-reference",children:"ServersTransportTCP reference"}),"\n",(0,t.jsxs)(n.p,{children:["By default, the referenced ServersTransportTCP CRD must be defined in the same ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," namespace."]}),"\n",(0,t.jsxs)(n.p,{children:["To reference a ServersTransportTCP CRD from another namespace,\nthe value must be of form ",(0,t.jsx)(n.code,{children:"namespace-name@kubernetescrd"}),",\nand the ",(0,t.jsx)(n.a,{href:"../../../providers/kubernetes-crd/#allowcrossnamespace",children:"allowCrossNamespace"})," option must be enabled."]}),"\n",(0,t.jsxs)(n.p,{children:["If the ServersTransportTCP CRD is defined in another provider the cross-provider format ",(0,t.jsx)(n.code,{children:"name@provider"})," should be used."]}),"\n",(0,t.jsx)(n.h2,{id:"further",children:"Further"}),"\n",(0,t.jsxs)(n.p,{children:["Also see the ",(0,t.jsx)(n.a,{href:"/doc/docs/user-guides/crd-acme/",children:"full example"})," with Let's Encrypt."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>c});var r=s(6540);const t={},i=r.createContext(t);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);