"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[5291],{7397:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"reference/routing-configuration/tcp/serverstransport","title":"ServersTransport TCP","description":"The ServersTransport allows configuring the connection between Mesh and the TCP servers in Kubernetes.","source":"@site/docs/reference/routing-configuration/tcp/serverstransport.md","sourceDirName":"reference/routing-configuration/tcp","slug":"/reference/routing-configuration/tcp/serverstransport","permalink":"/doc/docs/reference/routing-configuration/tcp/serverstransport","draft":false,"unlisted":false,"editUrl":"https://github.com/opendatav/mesh/tree/main/packages/create-docusaurus/templates/shared/docs/reference/routing-configuration/tcp/serverstransport.md","tags":[],"version":"current","frontMatter":{"title":"ServersTransport TCP","description":"The ServersTransport allows configuring the connection between Mesh and the TCP servers in Kubernetes."},"sidebar":"tutorialSidebar","previous":{"title":"Mesh TCP Routers Rules & Priority Documentation","permalink":"/doc/docs/reference/routing-configuration/tcp/router/rules-and-priority"},"next":{"title":"Mesh TCP Services Documentation","permalink":"/doc/docs/reference/routing-configuration/tcp/service"}}');var s=n(4848),i=n(8453);const l={title:"ServersTransport TCP",description:"The ServersTransport allows configuring the connection between Mesh and the TCP servers in Kubernetes."},o=void 0,c={},a=[{value:"Configuration Example",id:"configuration-example",level:2},{value:"Configuration Options",id:"configuration-options",level:2},{value:"<code>terminationDelay</code>",id:"terminationdelay",level:3}];function d(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"ServersTransport allows to configure the transport between Mesh and your TCP servers."}),"\n",(0,s.jsx)(t.h2,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,s.jsx)(t.p,{children:"Declare the serversTransport:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",metastring:'tab="Structured (YAML)"',children:'tcp:\n  serversTransports:\n    mytransport:\n      dialTimeout: "30s"\n      dialKeepAlive: "20s"\n      terminationDelay: "200ms"\n      tls:\n        serverName: "example.com"\n        certificates:\n          - "/path/to/cert1.pem"\n          - "/path/to/cert2.pem"\n        insecureSkipVerify: true\n        rootcas:\n          - "/path/to/rootca.pem"\n        peerCertURI: "spiffe://example.org/peer"\n      spiffe:\n        ids:\n          - "spiffe://example.org/id1"\n          - "spiffe://example.org/id2"\n        trustDomain: "example.org"\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-toml",metastring:'tab="Structured (TOML)"',children:'[tcp.serversTransports.mytransport]\n  dialTimeout = "30s"\n  dialKeepAlive = "20s"\n  terminationDelay = "200ms"\n\n  [tcp.serversTransports.mytransport.tls]\n    serverName = "example.com"\n    certificates = ["/path/to/cert1.pem", "/path/to/cert2.pem"]\n    insecureSkipVerify = true\n    rootcas = ["/path/to/rootca.pem"]\n    peerCertURI = "spiffe://example.org/peer"\n\n  [tcp.serversTransports.mytransport.spiffe]\n    ids = ["spiffe://example.org/id1", "spiffe://example.org/id2"]\n    trustDomain = "example.org"\n'})}),"\n",(0,s.jsx)(t.p,{children:"Attach the serversTransport to a service:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",metastring:'tab="Structured (YAML)"',children:"tcp:\n  services:\n    Service01:\n      loadBalancer:\n        serversTransport: mytransport\n"})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-toml",metastring:'tab="Structured(TOML)"',children:'## Dynamic configuration\n[tcp.services]\n  [tcp.services.Service01]\n    [tcp.services.Service01.loadBalancer]\n      serversTransport = "mytransport"\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",metastring:'tab="Labels"',children:'labels:\n  - "Mesh.tcp.services.Service01.loadBalancer.serversTransport=mytransport"\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-json",metastring:'tab="Tags"',children:'{\n  // ...\n  "Tags": [\n    "Mesh.tcp.services.Service01.loadBalancer.serversTransport=mytransport"\n  ]\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"configuration-options",children:"Configuration Options"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Field"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Description"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Default"}),(0,s.jsx)(t.th,{style:{textAlign:"left"},children:"Required"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.code,{children:"serverstransport."}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"dialTimeout"})]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Defines the timeout when dialing the backend TCP service. If zero, no timeout exists."}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"30s"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.code,{children:"serverstransport."}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"dialKeepAlive"})]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Defines the interval between keep-alive probes for an active network connection."}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"15s"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.code,{children:"serverstransport."}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"terminationDelay"})]}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Sets the time limit for the proxy to fully terminate connections on both sides after initiating the termination sequence, with a negative value indicating no deadline. More Information ",(0,s.jsx)(t.a,{href:"#terminationdelay",children:"here"})]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"100ms"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.code,{children:"serverstransport."}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"tls"})]}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Defines the TLS configuration. An empty ",(0,s.jsx)(t.code,{children:"tls"})," section enables TLS."]}),(0,s.jsx)(t.td,{style:{textAlign:"left"}}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.code,{children:"serverstransport."}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"tls"}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:".serverName"})]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Configures the server name that will be used for SNI."}),(0,s.jsx)(t.td,{style:{textAlign:"left"}}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.code,{children:"serverstransport."}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"tls"}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:".certificates"})]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Defines the list of certificates (as file paths, or data bytes) that will be set as client certificates for mTLS."}),(0,s.jsx)(t.td,{style:{textAlign:"left"}}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.code,{children:"serverstransport."}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"tls"}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:".insecureSkipVerify"})]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Controls whether the server's certificate chain and host name is verified."}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.code,{children:"serverstransport."}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"tls"}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:".rootcas"})]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Defines the root certificate authorities to use when verifying server certificates. (for mTLS connections)."}),(0,s.jsx)(t.td,{style:{textAlign:"left"}}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.code,{children:"serverstransport."}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"tls."}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"peerCertURI"})]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Defines the URI used to match against SAN URIs during the server's certificate verification."}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.code,{children:"serverstransport."}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"spiffe"}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:".ids"})]}),(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:["Allow SPIFFE IDs.",(0,s.jsx)("br",{}),"This takes precedence over the SPIFFE TrustDomain."]}),(0,s.jsx)(t.td,{style:{textAlign:"left"}}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,s.jsx)(t.code,{children:"serverstransport."}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:"spiffe"}),(0,s.jsx)("br",{}),(0,s.jsx)(t.code,{children:".trustDomain"})]}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"Allow SPIFFE trust domain."}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,s.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]})]})]}),"\n",(0,s.jsx)(t.p,{children:'!!! note "SPIFFE"'}),"\n",(0,s.jsxs)(t.p,{children:["Please note that SPIFFE must be enabled in the ",(0,s.jsx)(t.a,{href:"/doc/docs/reference/install-configuration/tls/spiffe",children:"install configuration"})," (formerly known as static configuration) before using it to secure the connection between Mesh and the backends."]}),"\n",(0,s.jsx)(t.h3,{id:"terminationdelay",children:(0,s.jsx)(t.code,{children:"terminationDelay"})}),"\n",(0,s.jsx)(t.p,{children:"As a proxy between a client and a server, it can happen that either side (e.g. client side) decides to terminate its writing capability on the connection (i.e. issuance of a FIN packet).\nThe proxy needs to propagate that intent to the other side, and so when that happens, it also does the same on its connection with the other side (e.g. backend side)."}),"\n",(0,s.jsx)(t.p,{children:"However, if for some reason (bad implementation, or malicious intent) the other side does not eventually do the same as well,\nthe connection would stay half-open, which would lock resources for however long."}),"\n",(0,s.jsx)(t.p,{children:"To that end, as soon as the proxy enters this termination sequence, it sets a deadline on fully terminating the connections on both sides."}),"\n",(0,s.jsx)(t.p,{children:"The termination delay controls that deadline.\nA negative value means an infinite deadline (i.e. the connection is never fully terminated by the proxy itself)."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>o});var r=n(6540);const s={},i=r.createContext(s);function l(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);