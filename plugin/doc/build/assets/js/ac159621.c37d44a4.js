"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[2263],{7816:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"reference/routing-configuration/kubernetes/crd/http/ingressroute","title":"Kubernetes IngressRoute","description":"An IngressRoute is a Mesh CRD is in charge of connecting incoming requests to the Services that can handle them in HTTP.","source":"@site/docs/reference/routing-configuration/kubernetes/crd/http/ingressroute.md","sourceDirName":"reference/routing-configuration/kubernetes/crd/http","slug":"/reference/routing-configuration/kubernetes/crd/http/ingressroute","permalink":"/doc/docs/reference/routing-configuration/kubernetes/crd/http/ingressroute","draft":false,"unlisted":false,"editUrl":"https://github.com/opendatav/mesh/tree/main/packages/create-docusaurus/templates/shared/docs/reference/routing-configuration/kubernetes/crd/http/ingressroute.md","tags":[],"version":"current","frontMatter":{"title":"Kubernetes IngressRoute","description":"An IngressRoute is a Mesh CRD is in charge of connecting incoming requests to the Services that can handle them in HTTP."},"sidebar":"tutorialSidebar","previous":{"title":"Mesh TLS Options Documentation","permalink":"/doc/docs/reference/routing-configuration/http/tls/tls-options"},"next":{"title":"Mesh Kubernetes Middleware Documentation","permalink":"/doc/docs/reference/routing-configuration/kubernetes/crd/http/middleware"}}');var r=n(4848),i=n(8453);const l={title:"Kubernetes IngressRoute",description:"An IngressRoute is a Mesh CRD is in charge of connecting incoming requests to the Services that can handle them in HTTP."},c=void 0,d={},o=[{value:"Configuration Example",id:"configuration-example",level:2},{value:"Configuration Options",id:"configuration-options",level:2},{value:"ExternalName Service",id:"externalname-service",level:3},{value:"Middleware",id:"middleware",level:3},{value:"Port Definition",id:"port-definition",level:3},{value:"TLS Options",id:"tls-options",level:3},{value:"Server Name Association",id:"server-name-association",level:4},{value:"Conflicting TLS Options",id:"conflicting-tls-options",level:4},{value:"Load Balancing",id:"load-balancing",level:3},{value:"Configuring Backend Protocol",id:"configuring-backend-protocol",level:3}];function a(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"IngressRoute"})," is the CRD implementation of a ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/routing-configuration/http/router/rules-and-priority",children:"Mesh HTTP router"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Before creating ",(0,r.jsx)(t.code,{children:"IngressRoute"})," objects, you need to apply the ",(0,r.jsx)(t.a,{href:"https://doc.Mesh.io/Mesh/reference/dynamic-configuration/kubernetes-crd/#definitions",children:"Mesh Kubernetes CRDs"})," to your Kubernetes cluster."]}),"\n",(0,r.jsxs)(t.p,{children:["This registers the ",(0,r.jsx)(t.code,{children:"IngressRoute"})," kind and other mesh-specific resources."]}),"\n",(0,r.jsx)(t.h2,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,r.jsxs)(t.p,{children:["You can declare an ",(0,r.jsx)(t.code,{children:"IngressRoute"})," as detailed below:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test-name\n  namespace: apps\n\nspec:\n  entryPoints:\n    - web\n  routes:\n  - kind: Rule\n    # Rule on the Host\n    match: Host(`test.example.com`)\n    # Attach a middleware\n    middlewares:\n    - name: middleware1\n      namespace: apps\n    # Enable Router observability\n    observability:\n      accessLogs: true\n      metrics: true\n      tracing: true\n    # Set a pirority\n    priority: 10\n    services:\n    # Target a Kubernetes Support\n    - kind: Service\n      name: foo\n      namespace: apps\n      # Customize the connection between Mesh and the backend\n      passHostHeader: true\n      port: 80\n      responseForwarding:\n        flushInterval: 1ms\n      scheme: https\n      sticky:\n        cookie:\n          httpOnly: true\n          name: cookie\n          secure: true\n      strategy: RoundRobin\n      weight: 10\n  tls:\n    # Generate a TLS certificate using a certificate resolver\n    certResolver: foo\n    domains:\n    - main: example.net\n      sans:\n      - a.example.net\n      - b.example.net\n    # Customize the TLS options\n    options:\n      name: opt\n      namespace: apps\n    # Add a TLS certificate from a Kubernetes Secret\n    secretName: supersecret\n"})}),"\n",(0,r.jsx)(t.h2,{id:"configuration-options",children:"Configuration Options"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Field"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Description"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Default"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Required"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"entryPoints"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["List of ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/install-configuration/entrypoints",children:"entry points"})," names.",(0,r.jsx)("br",{}),"If not specified, HTTP routers will accept requests from all EntryPoints in the list of default EntryPoints."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"}}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"routes"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"List of routes."}),(0,r.jsx)(t.td,{style:{textAlign:"left"}}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"routes[n].kind"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Kind of router matching, only ",(0,r.jsx)(t.code,{children:"Rule"})," is allowed yet."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'"Rule"'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"routes[n].match"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Defines the ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/routing-configuration/http/router/rules-and-priority#rules",children:"rule"})," corresponding to an underlying router."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"}}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"routes[n].priority"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Defines the ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/routing-configuration/http/router/rules-and-priority#priority-calculation",children:"priority"})," to disambiguate rules of the same length, for route matching.",(0,r.jsx)("br",{}),"If not set, the priority is directly equal to the length of the rule, and so the longest length has the highest priority.",(0,r.jsx)("br",{}),"A value of ",(0,r.jsx)(t.code,{children:"0"})," for the priority is ignored, the default rules length sorting is used."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"0"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"routes[n].middlewares"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["List of middlewares to attach to the IngressRoute. ",(0,r.jsx)("br",{}),"More information ",(0,r.jsx)(t.a,{href:"#middleware",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"middlewares[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"name"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Middleware name.",(0,r.jsx)("br",{}),"The character ",(0,r.jsx)(t.code,{children:"@"})," is not authorized. ",(0,r.jsx)("br",{}),"More information ",(0,r.jsx)(t.a,{href:"#middleware",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"}}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"middlewares[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"namespace"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Middleware namespace.",(0,r.jsx)("br",{}),"Can be empty if the middleware belongs to the same namespace as the IngressRoute. ",(0,r.jsx)("br",{}),"More information ",(0,r.jsx)(t.a,{href:"#middleware",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"}}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"observability."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"accesslogs"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Defines whether the route will produce ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/install-configuration/observability/logs-and-accesslogs",children:"access-logs"}),". See ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/routing-configuration/http/router/observability",children:"here"})," for more information."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"observability."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"metrics"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Defines whether the route will produce ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/install-configuration/observability/metrics",children:"metrics"}),". See ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/routing-configuration/http/router/observability",children:"here"})," for more information."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"observability."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"tracing"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Defines whether the route will produce ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/install-configuration/observability/tracing",children:"traces"}),". See ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/routing-configuration/http/router/observability",children:"here"})," for more information."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["List of any combination of MeshService and ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"}),". ",(0,r.jsx)("br",{}),"More information ",(0,r.jsx)(t.a,{href:"#externalname-service",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"}}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"kind"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Kind of the service targeted.",(0,r.jsx)("br",{}),"Two values allowed:",(0,r.jsx)("br",{}),"- ",(0,r.jsx)(t.strong,{children:"Service"}),": Kubernetes Service",(0,r.jsx)("br",{})," ",(0,r.jsx)(t.strong,{children:"MeshService"}),": Mesh Service.",(0,r.jsx)("br",{}),"More information ",(0,r.jsx)(t.a,{href:"#externalname-service",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'"Service"'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"name"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Service name.",(0,r.jsx)("br",{}),"The character ",(0,r.jsx)(t.code,{children:"@"})," is not authorized. ",(0,r.jsx)("br",{}),"More information ",(0,r.jsx)(t.a,{href:"#middleware",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"}}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"namespace"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Service namespace.",(0,r.jsx)("br",{}),"Can be empty if the service belongs to the same namespace as the IngressRoute. ",(0,r.jsx)("br",{}),"More information ",(0,r.jsx)(t.a,{href:"#externalname-service",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"}}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"port"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Service port (number or port name).",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"}}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"responseForwarding."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"flushInterval"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Interval, in milliseconds, in between flushes to the client while copying the response body.",(0,r.jsx)("br",{}),"A negative value means to flush immediately after each write to the client.",(0,r.jsx)("br",{}),"This configuration is ignored when a response is a streaming response; for such responses, writes are flushed to the client immediately.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"100ms"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"scheme"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Scheme to use for the request to the upstream Kubernetes Service.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),"."]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:['"http"',(0,r.jsx)("br",{}),'"https" if ',(0,r.jsx)(t.code,{children:"port"})," is 443 or contains the string ",(0,r.jsx)(t.em,{children:"https"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"serversTransport"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Name of ServersTransport resource to use to configure the transport between Mesh and your servers.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"passHostHeader"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Forward client Host header to server.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"true"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"healthCheck.scheme"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Server URL scheme for the health check endpoint.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),".",(0,r.jsx)("br",{}),"Only for ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," of type ",(0,r.jsx)(t.a,{href:"#externalname-service",children:"ExternalName"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"healthCheck.mode"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Health check mode.",(0,r.jsx)("br",{})," If defined to grpc, will use the gRPC health check protocol to probe the server.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),".",(0,r.jsx)("br",{}),"Only for ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," of type ",(0,r.jsx)(t.a,{href:"#externalname-service",children:"ExternalName"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'"http"'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"healthCheck.path"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Server URL path for the health check endpoint.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),".",(0,r.jsx)("br",{}),"Only for ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," of type ",(0,r.jsx)(t.a,{href:"#externalname-service",children:"ExternalName"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"healthCheck.interval"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Frequency of the health check calls for healthy targets.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),".",(0,r.jsx)("br",{}),"Only for ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," of type ",(0,r.jsx)(t.a,{href:"#externalname-service",children:"ExternalName"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'"100ms"'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"healthCheck.unhealthyInterval"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Frequency of the health check calls for unhealthy targets.",(0,r.jsx)("br",{}),"When not defined, it defaults to the ",(0,r.jsx)(t.code,{children:"interval"})," value.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),".",(0,r.jsx)("br",{}),"Only for ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," of type ",(0,r.jsx)(t.a,{href:"#externalname-service",children:"ExternalName"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'"100ms"'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"healthCheck.method"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["HTTP method for the health check endpoint.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),".",(0,r.jsx)("br",{}),"Only for ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," of type ",(0,r.jsx)(t.a,{href:"#externalname-service",children:"ExternalName"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'"GET"'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"healthCheck.status"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Expected HTTP status code of the response to the health check request.",(0,r.jsx)("br",{}),"Only for ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," of type ExternalName.",(0,r.jsx)("br",{}),"If not set, expect a status between 200 and 399.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"}}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"healthCheck.port"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["URL port for the health check endpoint.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),".",(0,r.jsx)("br",{}),"Only for ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," of type ",(0,r.jsx)(t.a,{href:"#externalname-service",children:"ExternalName"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"}}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"healthCheck.timeout"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Maximum duration to wait before considering the server unhealthy.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),".",(0,r.jsx)("br",{}),"Only for ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," of type ",(0,r.jsx)(t.a,{href:"#externalname-service",children:"ExternalName"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'"5s"'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"healthCheck.hostname"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Value in the Host header of the health check request.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),".",(0,r.jsx)("br",{}),"Only for ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," of type ",(0,r.jsx)(t.a,{href:"#externalname-service",children:"ExternalName"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"healthCheck."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"followRedirect"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Follow the redirections during the healtchcheck.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),".",(0,r.jsx)("br",{}),"Only for ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," of type ",(0,r.jsx)(t.a,{href:"#externalname-service",children:"ExternalName"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"true"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"healthCheck.headers"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Map of header to send to the health check endpoint",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),".",(0,r.jsx)("br",{}),"Only for ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," of type ",(0,r.jsx)(t.a,{href:"#externalname-service",children:"ExternalName"}),")."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"}}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"sticky."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"cookie.name"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Name of the cookie used for the stickiness.",(0,r.jsx)("br",{}),"When sticky sessions are enabled, a ",(0,r.jsx)(t.code,{children:"Set-Cookie"})," header is set on the initial response to let the client know which server handles the first response.",(0,r.jsx)("br",{}),"On subsequent requests, to keep the session alive with the same server, the client should send the cookie with the value set.",(0,r.jsx)("br",{}),"If the server pecified in the cookie becomes unhealthy, the request will be forwarded to a new server (and the cookie will keep track of the new server).",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"sticky."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"cookie.httpOnly"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Allow the cookie can be accessed by client-side APIs, such as JavaScript.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"sticky."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"cookie.secure"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Allow the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"sticky."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"cookie.sameSite"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite",children:"SameSite"})," policy",(0,r.jsx)("br",{}),"Allowed values:",(0,r.jsx)("br",{}),"-",(0,r.jsx)(t.code,{children:"none"}),(0,r.jsx)("br",{}),"-",(0,r.jsx)(t.code,{children:"lax"}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"strict"}),(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"sticky."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"cookie.maxAge"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Number of seconds until the cookie expires.",(0,r.jsx)("br",{}),"Negative number, the cookie expires immediately.",(0,r.jsx)("br",{}),"0, the cookie never expires.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"0"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"strategy"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Load balancing strategy between the servers.",(0,r.jsx)("br",{}),"RoundRobin is the only supported value yet.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'"RoundRobin"'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"weight"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Service weight.",(0,r.jsx)("br",{}),"To use only to refer to WRR MeshService"]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"nativeLB"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Allow using the Kubernetes Service load balancing between the pods instead of the one provided by Mesh.",(0,r.jsx)("br",{})," Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"routes[n]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"services[m]."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"nodePortLB"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Use the nodePort IP address when the service type is NodePort.",(0,r.jsx)("br",{}),"It allows services to be reachable when Mesh runs externally from the Kubernetes cluster but within the same network of the nodes.",(0,r.jsx)("br",{}),"Evaluated only if the kind is ",(0,r.jsx)(t.strong,{children:"Service"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"tls"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["TLS configuration.",(0,r.jsx)("br",{}),"Can be an empty value(",(0,r.jsx)(t.code,{children:"{}"}),"):",(0,r.jsx)("br",{}),"A self signed is generated in such a case",(0,r.jsx)("br",{}),"(or the ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/routing-configuration/kubernetes/crd/http/tlsstore",children:"default certificate"})," is used if it is defined.)"]}),(0,r.jsx)(t.td,{style:{textAlign:"left"}}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"tls.secretName"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/configuration/secret/",children:"Secret"})," name used to store the certificate (in the same namesapce as the ",(0,r.jsx)(t.code,{children:"IngressRoute"}),")"]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"tls."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"options.name"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Name of the ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/routing-configuration/kubernetes/crd/http/tlsoption",children:(0,r.jsx)(t.code,{children:"TLSOption"})})," to use.",(0,r.jsx)("br",{}),"More information ",(0,r.jsx)(t.a,{href:"#tls-options",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"tls."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"options.namespace"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Namespace of the ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/routing-configuration/kubernetes/crd/http/tlsoption",children:(0,r.jsx)(t.code,{children:"TLSOption"})})," to use."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"tls.certResolver"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Name of the ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/install-configuration/tls/certificate-resolvers/overview",children:"Certificate Resolver"})," to use to generate automatic TLS certificates."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"tls.domains"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["List of domains to serve using the certificates generates (one ",(0,r.jsx)(t.code,{children:"tls.domain"}),"= one certificate).",(0,r.jsx)("br",{}),"More information in the ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/install-configuration/tls/certificate-resolvers/acme#domain-definition",children:"dedicated section"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"}}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"tls."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"domains[n].main"})]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Main domain name"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:'""'}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"tls."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"domains[n].sans"})]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"List of alternative domains (SANs)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"}}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"externalname-service",children:"ExternalName Service"}),"\n",(0,r.jsxs)(t.p,{children:["Mesh backends creation needs a port to be set, however Kubernetes ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/#externalname",children:"ExternalName Service"})," could be defined without any port. Accordingly, Mesh supports defining a port in two ways:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["only on ",(0,r.jsx)(t.code,{children:"IngressRoute"})," service"]}),"\n",(0,r.jsxs)(t.li,{children:["on both sides, you'll be warned if the ports don't match, and the ",(0,r.jsx)(t.code,{children:"IngressRoute"})," service port is used"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Thus, in case of two sides port definition, Mesh expects a match between ports."}),"\n",(0,r.jsx)(t.p,{children:'=== "Ports defined on Resource"'}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test.route\n  namespace: apps\n\nspec:\n  entryPoints:\n    - foo\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: external-svc\n      port: 80\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="Service ExternalName"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: apps\n\nspec:\n  externalName: external.domain\n  type: ExternalName\n"})}),"\n",(0,r.jsx)(t.p,{children:'=== "Port defined on the Service"'}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test.route\n  namespace: apps\n\nspec:\n  entryPoints:\n    - foo\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: external-svc\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="Service ExternalName"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: apps\n\nspec:\n  externalName: external.domain\n  type: ExternalName\n  ports:\n    - port: 80\n"})}),"\n",(0,r.jsx)(t.p,{children:'=== "Port defined on both sides"'}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test.route\n  namespace: apps\n\nspec:\n  entryPoints:\n    - foo\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: external-svc\n      port: 80\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="Service ExternalName"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: apps\n\nspec:\n  externalName: external.domain\n  type: ExternalName\n  ports:\n    - port: 80\n"})}),"\n",(0,r.jsx)(t.h3,{id:"middleware",children:"Middleware"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["You can attach a list of ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/routing-configuration/http/middlewares/overview",children:"middlewares"}),"\nto each HTTP router."]}),"\n",(0,r.jsx)(t.li,{children:"The middlewares will take effect only if the rule matches, and before forwarding\nthe request to the service."}),"\n",(0,r.jsxs)(t.li,{children:["Middlewares are applied in the same order as their declaration in ",(0,r.jsx)(t.strong,{children:"router"}),"."]}),"\n",(0,r.jsxs)(t.li,{children:["In Kubernetes, the option ",(0,r.jsx)(t.code,{children:"middleware"})," allow you to attach a middleware using its\nname and namespace (the namespace can be omitted when the Middleware is in the\nsame namespace as the IngressRoute)"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:'??? example "IngressRoute attached to a few middlewares"'}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: my-app\n  namespace: apps\n\nspec:\n  entryPoints:\n    - websecure\n  routes:\n  - match: Host(`example.com`)\n    kind: Rule\n    middlewares:\n    # same namespace as the IngressRoute\n    - name: middleware01\n    # default namespace\n    - name: middleware02\n      namespace: apps\n    # Other namespace\n    - name: middleware03\n      namespace: other-ns\n    services:\n    - name: whoami\n      port: 80\n"})}),"\n",(0,r.jsx)(t.p,{children:'??? abstract "routes.services.kind"'}),"\n",(0,r.jsxs)(t.p,{children:["As the field ",(0,r.jsx)(t.code,{children:"name"})," can reference different types of objects, use the field ",(0,r.jsx)(t.code,{children:"kind"})," to avoid any ambiguity.\nThe field ",(0,r.jsx)(t.code,{children:"kind"})," allows the following values:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"Service"})," (default value): to reference a ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes Service"})]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"MeshService"}),": to reference an object ",(0,r.jsx)(t.a,{href:"../http/Meshservice.md",children:(0,r.jsx)(t.code,{children:"MeshService"})})]}),"\n"]}),"\n",(0,r.jsx)(t.h3,{id:"port-definition",children:"Port Definition"}),"\n",(0,r.jsxs)(t.p,{children:["Mesh backends creation needs a port to be set, however Kubernetes ",(0,r.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/#externalname",children:"ExternalName Service"})," could be defined without any port. Accordingly, Mesh supports defining a port in two ways:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["only on ",(0,r.jsx)(t.code,{children:"IngressRoute"})," service"]}),"\n",(0,r.jsxs)(t.li,{children:["on both sides, you'll be warned if the ports don't match, and the ",(0,r.jsx)(t.code,{children:"IngressRoute"})," service port is used"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Thus, in case of two sides port definition, Mesh expects a match between ports."}),"\n",(0,r.jsx)(t.p,{children:"??? example"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test.route\n  namespace: default\n\nspec:\n  entryPoints:\n    - foo\n\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: external-svc\n      port: 80\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: default\nspec:\n  externalName: external.domain\n  type: ExternalName\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="ExternalName Service"',children:"---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test.route\n  namespace: default\n\nspec:\n  entryPoints:\n    - foo\n\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: external-svc\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: default\nspec:\n  externalName: external.domain\n  type: ExternalName\n  ports:\n    - port: 80\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="Both sides"',children:"---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test.route\n  namespace: default\n\nspec:\n  entryPoints:\n    - foo\n\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: external-svc\n      port: 80\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: default\nspec:\n  externalName: external.domain\n  type: ExternalName\n  ports:\n    - port: 80\n"})}),"\n",(0,r.jsx)(t.h3,{id:"tls-options",children:"TLS Options"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"options"})," field enables fine-grained control of the TLS parameters.\nIt refers to a ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/routing-configuration/kubernetes/crd/http/tlsoption",children:"TLSOption"})," and will be applied only if a ",(0,r.jsx)(t.code,{children:"Host"}),"\nrule is defined."]}),"\n",(0,r.jsx)(t.h4,{id:"server-name-association",children:"Server Name Association"}),"\n",(0,r.jsxs)(t.p,{children:["A TLS options reference is always mapped to the host name found in the ",(0,r.jsx)(t.code,{children:"Host"}),"\npart of the rule, but neither to a router nor a router rule.\nThere could also be several ",(0,r.jsx)(t.code,{children:"Host"})," parts in a rule.\nIn such a case the TLS options reference would be mapped to as many host names."]}),"\n",(0,r.jsx)(t.p,{children:"A TLS option is picked from the mapping mentioned above and based on the server\nname provided during the TLS handshake,\nand it all happens before routing actually occurs."}),"\n",(0,r.jsxs)(t.p,{children:["In the case of domain fronting,\nif the TLS options associated with the Host Header and the SNI are different then\nMesh will respond with a status code ",(0,r.jsx)(t.code,{children:"421"}),"."]}),"\n",(0,r.jsx)(t.h4,{id:"conflicting-tls-options",children:"Conflicting TLS Options"}),"\n",(0,r.jsxs)(t.p,{children:["Since a TLS options reference is mapped to a host name, if a configuration introduces\na situation where the same host name (from a ",(0,r.jsx)(t.code,{children:"Host"})," rule) gets matched with two\nTLS options references, a conflict occurs, such as in the example below."]}),"\n",(0,r.jsx)(t.p,{children:"??? example"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="IngressRoute01"',children:"  apiVersion: Mesh.io/v1alpha1\n  kind: IngressRoute\n  metadata:\n    name: IngressRoute01\n    namespace: apps\n\n  spec:\n    entryPoints:\n      - foo\n    routes:\n    - match: Host(`example.net`)\n      kind: Rule\n    tls:\n      options: foo\n      ...\n\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="IngressRoute02"',children:"  apiVersion: Mesh.io/v1alpha1\n  kind: IngressRoute\n  metadata:\n    name: IngressRoute02\n    namespace: apps\n\n  spec:\n    entryPoints:\n      - foo\n    routes:\n    - match: Host(`example.net`)\n      kind: Rule\n    tls:\n      options: bar\n    ...\n"})}),"\n",(0,r.jsxs)(t.p,{children:["If that happens, both mappings are discarded, and the host name\n(",(0,r.jsx)(t.code,{children:"example.net"})," in the example) for these routers gets associated with\nthe default TLS options instead."]}),"\n",(0,r.jsx)(t.h3,{id:"load-balancing",children:"Load Balancing"}),"\n",(0,r.jsx)(t.p,{children:"You can declare and use Kubernetes Service load balancing as detailed below:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: ingressroutebar\n  namespace: default\n\nspec:\n  entryPoints:\n    - web\n  routes:\n  - match: Host(`example.com`) && PathPrefix(`/foo`)\n    kind: Rule\n    services:\n    - name: svc1\n      namespace: default\n    - name: svc2\n      namespace: default\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="K8s Service"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: svc1\n  namespace: default\n\nspec:\n  ports:\n    - name: http\n      port: 80\n  selector:\n    app: Meshlabs\n    task: app1\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: svc2\n  namespace: default\n\nspec:\n  ports:\n    - name: http\n      port: 80\n  selector:\n    app: Meshlabs\n    task: app2\n"})}),"\n",(0,r.jsx)(t.p,{children:'!!! important "Kubernetes Service Native Load-Balancing"'}),"\n",(0,r.jsxs)(t.p,{children:["To avoid creating the server load-balancer with the pod IPs and use Kubernetes Service clusterIP directly,\none should set the service ",(0,r.jsx)(t.code,{children:"NativeLB"})," option to true.\nPlease note that, by default, Mesh reuses the established connections to the backends for performance purposes. This can prevent the requests load balancing between the replicas from behaving as one would expect when the option is set.\nBy default, ",(0,r.jsx)(t.code,{children:"NativeLB"})," is false."]}),"\n",(0,r.jsx)(t.p,{children:'??? example "Example"'}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",children:"---\napiVersion: Mesh.io/v1alpha1\nkind: IngressRoute\nmetadata:\n  name: test.route\n  namespace: default\n\nspec:\n  entryPoints:\n    - foo\n\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: svc\n      port: 80\n      # Here, nativeLB instructs to build the server load-balancer with the Kubernetes Service clusterIP only.\n      nativeLB: true\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: svc\n  namespace: default\nspec:\n  type: ClusterIP\n  ...\n"})}),"\n",(0,r.jsx)(t.h3,{id:"configuring-backend-protocol",children:"Configuring Backend Protocol"}),"\n",(0,r.jsx)(t.p,{children:"There are 3 ways to configure the backend protocol for communication between Mesh and your pods:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Setting the scheme explicitly (http/https/h2c)"}),"\n",(0,r.jsx)(t.li,{children:"Configuring the name of the kubernetes service port to start with https (https)"}),"\n",(0,r.jsx)(t.li,{children:"Setting the kubernetes service port to use port 443 (https)"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"If you do not configure the above, Mesh will assume an http connection."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>c});var s=n(6540);const r={},i=s.createContext(r);function l(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);