"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[9416],{8453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>c});var t=n(6540);const r={},o=t.createContext(r);function i(e){const s=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(o.Provider,{value:s},e.children)}},9577:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>c,default:()=>l,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"user-guides/crd-acme/index","title":"Mesh CRD TLS Documentation","description":"Learn how to use Mesh Proxy w/ an IngressRoute Custom Resource Definition (CRD) for Kubernetes, and TLS with Let\'s Encrypt. Read the technical documentation.","source":"@site/docs/user-guides/crd-acme/index.md","sourceDirName":"user-guides/crd-acme","slug":"/user-guides/crd-acme/","permalink":"/doc/docs/user-guides/crd-acme/","draft":false,"unlisted":false,"editUrl":"https://github.com/opendatav/mesh/tree/main/packages/create-docusaurus/templates/shared/docs/user-guides/crd-acme/index.md","tags":[],"version":"current","frontMatter":{"title":"Mesh CRD TLS Documentation","description":"Learn how to use Mesh Proxy w/ an IngressRoute Custom Resource Definition (CRD) for Kubernetes, and TLS with Let\'s Encrypt. Read the technical documentation."},"sidebar":"tutorialSidebar","previous":{"title":"Integration with cert-manager","permalink":"/doc/docs/user-guides/cert-manager"},"next":{"title":"Mesh Docker DNS Challenge Documentation","permalink":"/doc/docs/user-guides/docker-compose/acme-dns/"}}');var r=n(4848),o=n(8453);const i={title:"Mesh CRD TLS Documentation",description:"Learn how to use Mesh Proxy w/ an IngressRoute Custom Resource Definition (CRD) for Kubernetes, and TLS with Let's Encrypt. Read the technical documentation."},c="Mesh & CRD & Let's Encrypt",a={},d=[{value:"k3s Docker-compose Configuration",id:"k3s-docker-compose-configuration",level:2},{value:"Cluster Resources",id:"cluster-resources",level:2},{value:"IngressRoute Definition",id:"ingressroute-definition",level:3},{value:"Services",id:"services",level:3},{value:"Deployments",id:"deployments",level:3},{value:"Port Forwarding",id:"port-forwarding",level:3},{value:"Mesh Routers",id:"mesh-routers",level:3},{value:"Force TLS v1.2+",id:"force-tls-v12",level:3}];function h(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"mesh--crd--lets-encrypt",children:"Mesh & CRD & Let's Encrypt"})}),"\n",(0,r.jsx)(s.p,{children:"Mesh with an IngressRoute Custom Resource Definition for Kubernetes, and TLS Through Let's Encrypt."}),"\n",(0,r.jsxs)(s.p,{children:["This document is intended to be a fully working example demonstrating how to set up Mesh in ",(0,r.jsx)(s.a,{href:"https://kubernetes.io",children:"Kubernetes"}),",\nwith the dynamic configuration coming from the ",(0,r.jsx)(s.a,{href:"/doc/docs/providers/kubernetes-crd",children:"IngressRoute Custom Resource"}),",\nand TLS setup with ",(0,r.jsx)(s.a,{href:"https://letsencrypt.org",children:"Let's Encrypt"}),".\nHowever, for the sake of simplicity, we're using ",(0,r.jsx)(s.a,{href:"https://github.com/rancher/k3s",children:"k3s"}),"  docker image for the Kubernetes cluster setup."]}),"\n",(0,r.jsx)(s.p,{children:"Please note that for this setup, given that we're going to use ACME's TLS-ALPN-01 challenge, the host you'll be running it on must be able to receive connections from the outside on port 443.\nAnd of course its internet facing IP address must match the domain name you intend to use."}),"\n",(0,r.jsx)(s.p,{children:"In the following, the Kubernetes resources defined in YAML configuration files can be applied to the setup in two different ways:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["the first, and usual way, is simply with the ",(0,r.jsx)(s.code,{children:"kubectl apply"})," command."]}),"\n",(0,r.jsxs)(s.li,{children:["the second, which can be used for this tutorial, is to directly place the files in the directory used by the k3s docker image for such inputs (",(0,r.jsx)(s.code,{children:"/var/lib/rancher/k3s/server/manifests"}),")."]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:'!!! important "Kubectl Version"'}),"\n",(0,r.jsxs)(s.p,{children:["With the ",(0,r.jsx)(s.code,{children:"rancher/k3s"})," version used in this guide (",(0,r.jsx)(s.code,{children:"0.8.0"}),"), the kubectl version needs to be >= ",(0,r.jsx)(s.code,{children:"1.11"}),"."]}),"\n",(0,r.jsx)(s.h2,{id:"k3s-docker-compose-configuration",children:"k3s Docker-compose Configuration"}),"\n",(0,r.jsx)(s.p,{children:"Our starting point is the docker-compose configuration file, to start the k3s cluster.\nYou can start it with:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"docker compose -f k3s.yml up\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:'--8<-- "content/user-guides/crd-acme/k3s.yml"\n'})}),"\n",(0,r.jsx)(s.h2,{id:"cluster-resources",children:"Cluster Resources"}),"\n",(0,r.jsxs)(s.p,{children:["Let's now have a look (in the order they should be applied, if using ",(0,r.jsx)(s.code,{children:"kubectl apply"}),") at all the required resources for the full setup."]}),"\n",(0,r.jsx)(s.h3,{id:"ingressroute-definition",children:"IngressRoute Definition"}),"\n",(0,r.jsxs)(s.p,{children:["First, you will need to install Mesh CRDs containing the definition of the ",(0,r.jsx)(s.code,{children:"IngressRoute"})," and the ",(0,r.jsx)(s.code,{children:"Middleware"})," kinds,\nand the RBAC authorization resources which will be referenced through the ",(0,r.jsx)(s.code,{children:"serviceAccountName"})," of the deployment."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"# Install Mesh Resource Definitions:\nkubectl apply -f https://raw.githubusercontent.com/Mesh/Mesh/v3.4/docs/content/reference/dynamic-configuration/kubernetes-crd-definition-v1.yml\n\n# Install RBAC for Mesh:\nkubectl apply -f https://raw.githubusercontent.com/Mesh/Mesh/v3.4/docs/content/reference/dynamic-configuration/kubernetes-crd-rbac.yml\n"})}),"\n",(0,r.jsx)(s.h3,{id:"services",children:"Services"}),"\n",(0,r.jsxs)(s.p,{children:["Then, the services. One for Mesh itself, and one for the app it routes for, i.e. in this case our demo HTTP server: ",(0,r.jsx)(s.a,{href:"https://github.com/Mesh/whoami",children:"whoami"}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"kubectl apply -f https://raw.githubusercontent.com/Mesh/Mesh/v3.4/docs/content/user-guides/crd-acme/02-services.yml\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:'--8<-- "content/user-guides/crd-acme/02-services.yml"\n'})}),"\n",(0,r.jsx)(s.h3,{id:"deployments",children:"Deployments"}),"\n",(0,r.jsx)(s.p,{children:"Next, the deployments, i.e. the actual pods behind the services.\nAgain, one pod for Mesh, and one for the whoami app."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"kubectl apply -f https://raw.githubusercontent.com/Mesh/Mesh/v3.4/docs/content/user-guides/crd-acme/03-deployments.yml\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:'--8<-- "content/user-guides/crd-acme/03-deployments.yml"\n'})}),"\n",(0,r.jsx)(s.h3,{id:"port-forwarding",children:"Port Forwarding"}),"\n",(0,r.jsx)(s.p,{children:"Now, as an exception to what we said above, please note that you should not let the ingressRoute resources below be applied automatically to your cluster.\nThe reason is, as soon as the ACME provider of Mesh detects we have TLS routers, it will try to generate the certificates for the corresponding domains.\nAnd this will not work, because as it is, our Mesh pod is not reachable from the outside, which will make the ACME TLS challenge fail.\nTherefore, for the whole thing to work, we must delay applying the ingressRoute resources until we have port-forwarding set up properly, which is the next step."}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"kubectl port-forward --address 0.0.0.0 service/Mesh 8000:8000 8080:8080 443:4443 -n default\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Also, and this is out of the scope of this guide, please note that because of the privileged ports limitation on Linux, the above command might fail to listen on port 443.\nIn which case you can use tricks such as elevating caps of ",(0,r.jsx)(s.code,{children:"kubectl"})," with ",(0,r.jsx)(s.code,{children:"setcaps"}),", or using ",(0,r.jsx)(s.code,{children:"authbind"}),", or setting up a NAT between your host and the WAN.\nLook it up."]}),"\n",(0,r.jsx)(s.h3,{id:"mesh-routers",children:"Mesh Routers"}),"\n",(0,r.jsx)(s.p,{children:"We can now finally apply the actual ingressRoutes, with:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"kubectl apply -f https://raw.githubusercontent.com/Mesh/Mesh/v3.4/docs/content/user-guides/crd-acme/04-ingressroutes.yml\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:'--8<-- "content/user-guides/crd-acme/04-ingressroutes.yml"\n'})}),"\n",(0,r.jsx)(s.p,{children:"Give it a few seconds for the ACME TLS challenge to complete, and you should then be able to access your whoami pod (routed through Mesh), from the outside.\nBoth with or (just for fun, do not do that in production) without TLS:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"curl [-k] https://your.example.com/tls\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"curl http://your.example.com:8000/notls\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Note that you'll have to use ",(0,r.jsx)(s.code,{children:"-k"})," as long as you're using the staging server of Let's Encrypt, since it is not an authorized certificate authority on systems where it hasn't been manually added."]}),"\n",(0,r.jsx)(s.h3,{id:"force-tls-v12",children:"Force TLS v1.2+"}),"\n",(0,r.jsxs)(s.p,{children:["Nowadays, TLS v1.0 and v1.1 are deprecated.\nIn order to force TLS v1.2 or later on all your IngressRoute, you can define the ",(0,r.jsx)(s.code,{children:"default"})," TLSOption:"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"kubectl apply -f https://raw.githubusercontent.com/Mesh/Mesh/v3.4/docs/content/user-guides/crd-acme/05-tlsoption.yml\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:'--8<-- "content/user-guides/crd-acme/05-tlsoption.yml"\n'})})]})}function l(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);