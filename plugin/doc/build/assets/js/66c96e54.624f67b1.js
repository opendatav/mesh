"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[491],{6343:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>h,contentTitle:()=>i,default:()=>E,frontMatter:()=>l,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"reference/static-configuration/env-ref","title":"env-ref","description":"\x3c!--","source":"@site/docs/reference/static-configuration/env-ref.md","sourceDirName":"reference/static-configuration","slug":"/reference/static-configuration/env-ref","permalink":"/doc/docs/reference/static-configuration/env-ref","draft":false,"unlisted":false,"editUrl":"https://github.com/opendatav/mesh/tree/main/packages/create-docusaurus/templates/shared/docs/reference/static-configuration/env-ref.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Mesh CLI Flags Documentation","permalink":"/doc/docs/reference/static-configuration/cli"},"next":{"title":"Mesh Environment Variables Documentation","permalink":"/doc/docs/reference/static-configuration/env"}}');var c=n(4848),d=n(8453);const l={},i=void 0,h={},o=[];function t(e){const s={br:"br",code:"code",p:"p",...(0,d.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG"}),":",(0,c.jsx)(s.br,{}),"\n","Access log settings. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_ADDINTERNALS"}),":",(0,c.jsx)(s.br,{}),"\n","Enables access log for internal services (ping, dashboard, etc...). (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_BUFFERINGSIZE"}),":",(0,c.jsx)(s.br,{}),"\n","Number of access log lines to process in a buffered way. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_FIELDS_DEFAULTMODE"}),":",(0,c.jsx)(s.br,{}),"\n","Default mode for fields: keep | drop (Default: ",(0,c.jsx)(s.code,{children:"keep"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_FIELDS_HEADERS_DEFAULTMODE"}),":",(0,c.jsx)(s.br,{}),"\n","Default mode for fields: keep | drop | redact (Default: ",(0,c.jsx)(s.code,{children:"drop"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_FIELDS_HEADERS_NAMES_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Override mode for headers"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_FIELDS_NAMES_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Override mode for fields"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_FILEPATH"}),":",(0,c.jsx)(s.br,{}),"\n","Access log file path. Stdout is used when omitted or empty."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_FILTERS_MINDURATION"}),":",(0,c.jsx)(s.br,{}),"\n","Keep access logs when request took longer than the specified duration. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_FILTERS_RETRYATTEMPTS"}),":",(0,c.jsx)(s.br,{}),"\n","Keep access logs when at least one retry happened. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_FILTERS_STATUSCODES"}),":",(0,c.jsx)(s.br,{}),"\n","Keep access logs with status codes in the specified range."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_FORMAT"}),":",(0,c.jsx)(s.br,{}),"\n","Access log format: json | common (Default: ",(0,c.jsx)(s.code,{children:"common"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP"}),":",(0,c.jsx)(s.br,{}),"\n","Settings for OpenTelemetry. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_GRPC"}),":",(0,c.jsx)(s.br,{}),"\n","gRPC configuration for the OpenTelemetry collector. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_GRPC_ENDPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","Sets the gRPC endpoint (host",":port",") of the collector. (Default: ",(0,c.jsx)(s.code,{children:"localhost:4317"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_GRPC_HEADERS_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Headers sent with payload."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_GRPC_INSECURE"}),":",(0,c.jsx)(s.br,{}),"\n","Disables client transport security for the exporter. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_GRPC_TLS_CA"}),":",(0,c.jsx)(s.br,{}),"\n","TLS CA"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_GRPC_TLS_CERT"}),":",(0,c.jsx)(s.br,{}),"\n","TLS cert"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_GRPC_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS insecure skip verify (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_GRPC_TLS_KEY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS key"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_HTTP"}),":",(0,c.jsx)(s.br,{}),"\n","HTTP configuration for the OpenTelemetry collector. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_HTTP_ENDPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","Sets the HTTP endpoint (scheme://host",":port","/path) of the collector. (Default: ",(0,c.jsx)(s.code,{children:"https://localhost:4318"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_HTTP_HEADERS_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Headers sent with payload."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_HTTP_TLS_CA"}),":",(0,c.jsx)(s.br,{}),"\n","TLS CA"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_HTTP_TLS_CERT"}),":",(0,c.jsx)(s.br,{}),"\n","TLS cert"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_HTTP_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS insecure skip verify (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_HTTP_TLS_KEY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS key"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_RESOURCEATTRIBUTES_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Defines additional resource attributes (key",":value",")."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ACCESSLOG_OTLP_SERVICENAME"}),":",(0,c.jsx)(s.br,{}),"\n","Set the name for this service. (Default: ",(0,c.jsx)(s.code,{children:"Mesh"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_API"}),":",(0,c.jsx)(s.br,{}),"\n","Enable api/dashboard. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_API_BASEPATH"}),":",(0,c.jsx)(s.br,{}),"\n","Defines the base path where the API and Dashboard will be exposed. (Default: ",(0,c.jsx)(s.code,{children:"/"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_API_DASHBOARD"}),":",(0,c.jsx)(s.br,{}),"\n","Activate dashboard. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_API_DEBUG"}),":",(0,c.jsx)(s.br,{}),"\n","Enable additional endpoints for debugging and profiling. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_API_DISABLEDASHBOARDAD"}),":",(0,c.jsx)(s.br,{}),"\n","Disable ad in the dashboard. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_API_INSECURE"}),":",(0,c.jsx)(s.br,{}),"\n","Activate API directly on the entryPoint named Mesh. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Certificates resolvers configuration. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_CACERTIFICATES"}),":",(0,c.jsx)(s.br,{}),"\n","Specify the paths to PEM encoded CA Certificates that can be used to authenticate an ACME server with an HTTPS certificate not issued by a CA in the system-wide trusted root list."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_CASERVER"}),":",(0,c.jsx)(s.br,{}),"\n","CA server to use. (Default: ",(0,c.jsx)(s.code,{children:"https://acme-v02.api.letsencrypt.org/directory"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_CASERVERNAME"}),":",(0,c.jsx)(s.br,{}),"\n","Specify the CA server name that can be used to authenticate an ACME server with an HTTPS certificate not issued by a CA in the system-wide trusted root list."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_CASYSTEMCERTPOOL"}),":",(0,c.jsx)(s.br,{}),"\n","Define if the certificates pool must use a copy of the system cert pool. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_CERTIFICATESDURATION"}),":",(0,c.jsx)(s.br,{}),"\n","Certificates' duration in hours. (Default: ",(0,c.jsx)(s.code,{children:"2160"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_CLIENTRESPONSEHEADERTIMEOUT"}),":",(0,c.jsx)(s.br,{}),"\n","Timeout for receiving the response headers when communicating with the ACME server. (Default: ",(0,c.jsx)(s.code,{children:"30"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_CLIENTTIMEOUT"}),":",(0,c.jsx)(s.br,{}),"\n","Timeout for a complete HTTP transaction with the ACME server. (Default: ",(0,c.jsx)(s.code,{children:"120"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE"}),":",(0,c.jsx)(s.br,{}),"\n","Activate DNS-01 Challenge. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_DELAYBEFORECHECK"}),":",(0,c.jsx)(s.br,{}),"\n","(Deprecated) Assume DNS propagates after a delay in seconds rather than finding and querying nameservers. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_DISABLEPROPAGATIONCHECK"}),":",(0,c.jsx)(s.br,{}),"\n","(Deprecated) Disable the DNS propagation checks before notifying ACME that the DNS challenge is ready. [not recommended] (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_PROPAGATION"}),":",(0,c.jsx)(s.br,{}),"\n","DNS propagation checks configuration (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_PROPAGATION_DELAYBEFORECHECKS"}),":",(0,c.jsx)(s.br,{}),"\n","Defines the delay before checking the challenge TXT record propagation. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_PROPAGATION_DISABLEANSCHECKS"}),":",(0,c.jsx)(s.br,{}),"\n","Disables the challenge TXT record propagation checks against authoritative nameservers. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_PROPAGATION_DISABLECHECKS"}),":",(0,c.jsx)(s.br,{}),"\n","Disables the challenge TXT record propagation checks (not recommended). (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_PROPAGATION_REQUIREALLRNS"}),":",(0,c.jsx)(s.br,{}),"\n","Requires the challenge TXT record to be propagated to all recursive nameservers. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_PROVIDER"}),":",(0,c.jsx)(s.br,{}),"\n","Use a DNS-01 based challenge provider rather than HTTPS."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_DNSCHALLENGE_RESOLVERS"}),":",(0,c.jsx)(s.br,{}),"\n","Use following DNS servers to resolve the FQDN authority."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_EAB_HMACENCODED"}),":",(0,c.jsx)(s.br,{}),"\n","Base64 encoded HMAC key from External CA."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_EAB_KID"}),":",(0,c.jsx)(s.br,{}),"\n","Key identifier from External CA."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_EMAIL"}),":",(0,c.jsx)(s.br,{}),"\n","Email address used for registration."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_EMAILADDRESSES"}),":",(0,c.jsx)(s.br,{}),"\n","CSR email addresses to use."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_HTTPCHALLENGE"}),":",(0,c.jsx)(s.br,{}),"\n","Activate HTTP-01 Challenge. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_HTTPCHALLENGE_DELAY"}),":",(0,c.jsx)(s.br,{}),"\n","Delay between the creation of the challenge and the validation. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_HTTPCHALLENGE_ENTRYPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","HTTP challenge EntryPoint"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_KEYTYPE"}),":",(0,c.jsx)(s.br,{}),"\n","KeyType used for generating certificate private key. Allow value 'EC256', 'EC384', 'RSA2048', 'RSA4096', 'RSA8192'. (Default: ",(0,c.jsx)(s.code,{children:"RSA4096"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_PREFERREDCHAIN"}),":",(0,c.jsx)(s.br,{}),"\n","Preferred chain to use."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_PROFILE"}),":",(0,c.jsx)(s.br,{}),"\n","Certificate profile to use."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_STORAGE"}),":",(0,c.jsx)(s.br,{}),"\n","Storage to use. (Default: ",(0,c.jsx)(s.code,{children:"acme.json"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_ACME_TLSCHALLENGE"}),":",(0,c.jsx)(s.br,{}),"\n","Activate TLS-ALPN-01 Challenge. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CERTIFICATESRESOLVERS_<NAME>_TAILSCALE"}),":",(0,c.jsx)(s.br,{}),"\n","Enables Tailscale certificate resolution. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_CORE_DEFAULTRULESYNTAX"}),":",(0,c.jsx)(s.br,{}),"\n","Defines the rule parser default syntax (v2 or v3) (Default: ",(0,c.jsx)(s.code,{children:"v3"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Entry points definition. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_ADDRESS"}),":",(0,c.jsx)(s.br,{}),"\n","Entry point address."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_ALLOWACMEBYPASS"}),":",(0,c.jsx)(s.br,{}),"\n","Enables handling of ACME TLS and HTTP challenges with custom routers. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_ASDEFAULT"}),":",(0,c.jsx)(s.br,{}),"\n","Adds this EntryPoint to the list of default EntryPoints to be used on routers that don't have any Entrypoint defined. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_FORWARDEDHEADERS_CONNECTION"}),":",(0,c.jsx)(s.br,{}),"\n","List of Connection headers that are allowed to pass through the middleware chain before being removed."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_FORWARDEDHEADERS_INSECURE"}),":",(0,c.jsx)(s.br,{}),"\n","Trust all forwarded headers. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_FORWARDEDHEADERS_TRUSTEDIPS"}),":",(0,c.jsx)(s.br,{}),"\n","Trust only forwarded headers from selected IPs."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP"}),":",(0,c.jsx)(s.br,{}),"\n","HTTP configuration."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP2_MAXCONCURRENTSTREAMS"}),":",(0,c.jsx)(s.br,{}),"\n","Specifies the number of concurrent streams per connection that each client is allowed to initiate. (Default: ",(0,c.jsx)(s.code,{children:"250"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP3"}),":",(0,c.jsx)(s.br,{}),"\n","HTTP/3 configuration. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP3_ADVERTISEDPORT"}),":",(0,c.jsx)(s.br,{}),"\n","UDP port to advertise, on which HTTP/3 is available. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP_ENCODEQUERYSEMICOLONS"}),":",(0,c.jsx)(s.br,{}),"\n","Defines whether request query semicolons should be URLEncoded. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP_MAXHEADERBYTES"}),":",(0,c.jsx)(s.br,{}),"\n","Maximum size of request headers in bytes. (Default: ",(0,c.jsx)(s.code,{children:"1048576"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP_MIDDLEWARES"}),":",(0,c.jsx)(s.br,{}),"\n","Default middlewares for the routers linked to the entry point."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP_REDIRECTIONS_ENTRYPOINT_PERMANENT"}),":",(0,c.jsx)(s.br,{}),"\n","Applies a permanent redirection. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP_REDIRECTIONS_ENTRYPOINT_PRIORITY"}),":",(0,c.jsx)(s.br,{}),"\n","Priority of the generated router. (Default: ",(0,c.jsx)(s.code,{children:"9223372036854775806"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP_REDIRECTIONS_ENTRYPOINT_SCHEME"}),":",(0,c.jsx)(s.br,{}),"\n","Scheme used for the redirection. (Default: ",(0,c.jsx)(s.code,{children:"https"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP_REDIRECTIONS_ENTRYPOINT_TO"}),":",(0,c.jsx)(s.br,{}),"\n","Targeted entry point of the redirection."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP_SANITIZEPATH"}),":",(0,c.jsx)(s.br,{}),"\n","Defines whether to enable request path sanitization (removal of /./, /../ and multiple slash sequences). (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP_TLS"}),":",(0,c.jsx)(s.br,{}),"\n","Default TLS configuration for the routers linked to the entry point. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP_TLS_CERTRESOLVER"}),":",(0,c.jsx)(s.br,{}),"\n","Default certificate resolver for the routers linked to the entry point."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP_TLS_DOMAINS"}),":",(0,c.jsx)(s.br,{}),"\n","Default TLS domains for the routers linked to the entry point."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP_TLS_DOMAINS_n_MAIN"}),":",(0,c.jsx)(s.br,{}),"\n","Default subject name."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP_TLS_DOMAINS_n_SANS"}),":",(0,c.jsx)(s.br,{}),"\n","Subject alternative names."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_HTTP_TLS_OPTIONS"}),":",(0,c.jsx)(s.br,{}),"\n","Default TLS options for the routers linked to the entry point."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_OBSERVABILITY_ACCESSLOGS"}),":",(0,c.jsx)(s.br,{}),"\n","(Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_OBSERVABILITY_METRICS"}),":",(0,c.jsx)(s.br,{}),"\n","(Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_OBSERVABILITY_TRACING"}),":",(0,c.jsx)(s.br,{}),"\n","(Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_PROXYPROTOCOL"}),":",(0,c.jsx)(s.br,{}),"\n","Proxy-Protocol configuration. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_PROXYPROTOCOL_INSECURE"}),":",(0,c.jsx)(s.br,{}),"\n","Trust all. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_PROXYPROTOCOL_TRUSTEDIPS"}),":",(0,c.jsx)(s.br,{}),"\n","Trust only selected IPs."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_REUSEPORT"}),":",(0,c.jsx)(s.br,{}),"\n","Enables EntryPoints from the same or different processes listening on the same TCP/UDP port. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_TRANSPORT_KEEPALIVEMAXREQUESTS"}),":",(0,c.jsx)(s.br,{}),"\n","Maximum number of requests before closing a keep-alive connection. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_TRANSPORT_KEEPALIVEMAXTIME"}),":",(0,c.jsx)(s.br,{}),"\n","Maximum duration before closing a keep-alive connection. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_TRANSPORT_LIFECYCLE_GRACETIMEOUT"}),":",(0,c.jsx)(s.br,{}),"\n","Duration to give active requests a chance to finish before Mesh stops. (Default: ",(0,c.jsx)(s.code,{children:"10"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_TRANSPORT_LIFECYCLE_REQUESTACCEPTGRACETIMEOUT"}),":",(0,c.jsx)(s.br,{}),"\n","Duration to keep accepting requests before Mesh initiates the graceful shutdown procedure. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_TRANSPORT_RESPONDINGTIMEOUTS_IDLETIMEOUT"}),":",(0,c.jsx)(s.br,{}),"\n","IdleTimeout is the maximum amount duration an idle (keep-alive) connection will remain idle before closing itself. If zero, no timeout is set. (Default: ",(0,c.jsx)(s.code,{children:"180"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_TRANSPORT_RESPONDINGTIMEOUTS_READTIMEOUT"}),":",(0,c.jsx)(s.br,{}),"\n","ReadTimeout is the maximum duration for reading the entire request, including the body. If zero, no timeout is set. (Default: ",(0,c.jsx)(s.code,{children:"60"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_TRANSPORT_RESPONDINGTIMEOUTS_WRITETIMEOUT"}),":",(0,c.jsx)(s.br,{}),"\n","WriteTimeout is the maximum duration before timing out writes of the response. If zero, no timeout is set. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_ENTRYPOINTS_<NAME>_UDP_TIMEOUT"}),":",(0,c.jsx)(s.br,{}),"\n","Timeout defines how long to wait on an idle session before releasing the related resources. (Default: ",(0,c.jsx)(s.code,{children:"3"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_ABORTONPLUGINFAILURE"}),":",(0,c.jsx)(s.br,{}),"\n","Defines whether all plugins must be loaded successfully for Mesh to start. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_FASTPROXY"}),":",(0,c.jsx)(s.br,{}),"\n","Enables the FastProxy implementation. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_FASTPROXY_DEBUG"}),":",(0,c.jsx)(s.br,{}),"\n","Enable debug mode for the FastProxy implementation. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_KUBERNETESGATEWAY"}),":",(0,c.jsx)(s.br,{}),"\n","(Deprecated) Allow the Kubernetes gateway api provider usage. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_LOCALPLUGINS_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Local plugins configuration. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_LOCALPLUGINS_<NAME>_MODULENAME"}),":",(0,c.jsx)(s.br,{}),"\n","Plugin's module name."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_LOCALPLUGINS_<NAME>_SETTINGS"}),":",(0,c.jsx)(s.br,{}),"\n","Plugin's settings (works only for wasm plugins)."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_LOCALPLUGINS_<NAME>_SETTINGS_ENVS"}),":",(0,c.jsx)(s.br,{}),"\n","Environment variables to forward to the wasm guest."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_LOCALPLUGINS_<NAME>_SETTINGS_MOUNTS"}),":",(0,c.jsx)(s.br,{}),"\n","Directory to mount to the wasm guest."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_LOCALPLUGINS_<NAME>_SETTINGS_USEUNSAFE"}),":",(0,c.jsx)(s.br,{}),"\n","Allow the plugin to use unsafe package. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_OTLPLOGS"}),":",(0,c.jsx)(s.br,{}),"\n","Enables the OpenTelemetry logs integration. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_PLUGINS_<NAME>_MODULENAME"}),":",(0,c.jsx)(s.br,{}),"\n","plugin's module name."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_PLUGINS_<NAME>_SETTINGS"}),":",(0,c.jsx)(s.br,{}),"\n","Plugin's settings (works only for wasm plugins)."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_PLUGINS_<NAME>_SETTINGS_ENVS"}),":",(0,c.jsx)(s.br,{}),"\n","Environment variables to forward to the wasm guest."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_PLUGINS_<NAME>_SETTINGS_MOUNTS"}),":",(0,c.jsx)(s.br,{}),"\n","Directory to mount to the wasm guest."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_PLUGINS_<NAME>_SETTINGS_USEUNSAFE"}),":",(0,c.jsx)(s.br,{}),"\n","Allow the plugin to use unsafe package. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_EXPERIMENTAL_PLUGINS_<NAME>_VERSION"}),":",(0,c.jsx)(s.br,{}),"\n","plugin's version."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_GLOBAL_CHECKNEWVERSION"}),":",(0,c.jsx)(s.br,{}),"\n","Periodically check if a new version has been released. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_GLOBAL_SENDANONYMOUSUSAGE"}),":",(0,c.jsx)(s.br,{}),"\n","Periodically send anonymous usage statistics. If the option is not specified, it will be disabled by default. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_HOSTRESOLVER"}),":",(0,c.jsx)(s.br,{}),"\n","Enable CNAME Flattening. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_HOSTRESOLVER_CNAMEFLATTENING"}),":",(0,c.jsx)(s.br,{}),"\n","A flag to enable/disable CNAME flattening (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_HOSTRESOLVER_RESOLVCONFIG"}),":",(0,c.jsx)(s.br,{}),"\n","resolv.conf used for DNS resolving (Default: ",(0,c.jsx)(s.code,{children:"/etc/resolv.conf"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_HOSTRESOLVER_RESOLVDEPTH"}),":",(0,c.jsx)(s.br,{}),"\n","The maximal depth of DNS recursive resolving (Default: ",(0,c.jsx)(s.code,{children:"5"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG"}),":",(0,c.jsx)(s.br,{}),"\n","Mesh log settings. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_COMPRESS"}),":",(0,c.jsx)(s.br,{}),"\n","Determines if the rotated log files should be compressed using gzip. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_FILEPATH"}),":",(0,c.jsx)(s.br,{}),"\n","Mesh log file path. Stdout is used when omitted or empty."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_FORMAT"}),":",(0,c.jsx)(s.br,{}),"\n","Mesh log format: json | common (Default: ",(0,c.jsx)(s.code,{children:"common"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_LEVEL"}),":",(0,c.jsx)(s.br,{}),"\n","Log level set to Mesh logs. (Default: ",(0,c.jsx)(s.code,{children:"ERROR"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_MAXAGE"}),":",(0,c.jsx)(s.br,{}),"\n","Maximum number of days to retain old log files based on the timestamp encoded in their filename. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_MAXBACKUPS"}),":",(0,c.jsx)(s.br,{}),"\n","Maximum number of old log files to retain. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_MAXSIZE"}),":",(0,c.jsx)(s.br,{}),"\n","Maximum size in megabytes of the log file before it gets rotated. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_NOCOLOR"}),":",(0,c.jsx)(s.br,{}),"\n","When using the 'common' format, disables the colorized output. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP"}),":",(0,c.jsx)(s.br,{}),"\n","Settings for OpenTelemetry. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_GRPC"}),":",(0,c.jsx)(s.br,{}),"\n","gRPC configuration for the OpenTelemetry collector. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_GRPC_ENDPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","Sets the gRPC endpoint (host",":port",") of the collector. (Default: ",(0,c.jsx)(s.code,{children:"localhost:4317"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_GRPC_HEADERS_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Headers sent with payload."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_GRPC_INSECURE"}),":",(0,c.jsx)(s.br,{}),"\n","Disables client transport security for the exporter. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_GRPC_TLS_CA"}),":",(0,c.jsx)(s.br,{}),"\n","TLS CA"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_GRPC_TLS_CERT"}),":",(0,c.jsx)(s.br,{}),"\n","TLS cert"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_GRPC_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS insecure skip verify (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_GRPC_TLS_KEY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS key"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_HTTP"}),":",(0,c.jsx)(s.br,{}),"\n","HTTP configuration for the OpenTelemetry collector. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_HTTP_ENDPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","Sets the HTTP endpoint (scheme://host",":port","/path) of the collector. (Default: ",(0,c.jsx)(s.code,{children:"https://localhost:4318"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_HTTP_HEADERS_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Headers sent with payload."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_HTTP_TLS_CA"}),":",(0,c.jsx)(s.br,{}),"\n","TLS CA"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_HTTP_TLS_CERT"}),":",(0,c.jsx)(s.br,{}),"\n","TLS cert"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_HTTP_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS insecure skip verify (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_HTTP_TLS_KEY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS key"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_RESOURCEATTRIBUTES_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Defines additional resource attributes (key",":value",")."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_LOG_OTLP_SERVICENAME"}),":",(0,c.jsx)(s.br,{}),"\n","Set the name for this service. (Default: ",(0,c.jsx)(s.code,{children:"Mesh"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_ADDINTERNALS"}),":",(0,c.jsx)(s.br,{}),"\n","Enables metrics for internal services (ping, dashboard, etc...). (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_DATADOG"}),":",(0,c.jsx)(s.br,{}),"\n","Datadog metrics exporter type. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_DATADOG_ADDENTRYPOINTSLABELS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable metrics on entry points. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_DATADOG_ADDRESS"}),":",(0,c.jsx)(s.br,{}),"\n","Datadog's address. (Default: ",(0,c.jsx)(s.code,{children:"localhost:8125"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_DATADOG_ADDROUTERSLABELS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable metrics on routers. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_DATADOG_ADDSERVICESLABELS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable metrics on services. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_DATADOG_PREFIX"}),":",(0,c.jsx)(s.br,{}),"\n","Prefix to use for metrics collection. (Default: ",(0,c.jsx)(s.code,{children:"Mesh"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_DATADOG_PUSHINTERVAL"}),":",(0,c.jsx)(s.br,{}),"\n","Datadog push interval. (Default: ",(0,c.jsx)(s.code,{children:"10"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_INFLUXDB2"}),":",(0,c.jsx)(s.br,{}),"\n","InfluxDB v2 metrics exporter type. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_INFLUXDB2_ADDENTRYPOINTSLABELS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable metrics on entry points. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_INFLUXDB2_ADDITIONALLABELS_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Additional labels (influxdb tags) on all metrics"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_INFLUXDB2_ADDRESS"}),":",(0,c.jsx)(s.br,{}),"\n","InfluxDB v2 address. (Default: ",(0,c.jsx)(s.code,{children:"http://localhost:8086"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_INFLUXDB2_ADDROUTERSLABELS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable metrics on routers. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_INFLUXDB2_ADDSERVICESLABELS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable metrics on services. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_INFLUXDB2_BUCKET"}),":",(0,c.jsx)(s.br,{}),"\n","InfluxDB v2 bucket ID."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_INFLUXDB2_ORG"}),":",(0,c.jsx)(s.br,{}),"\n","InfluxDB v2 org ID."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_INFLUXDB2_PUSHINTERVAL"}),":",(0,c.jsx)(s.br,{}),"\n","InfluxDB v2 push interval. (Default: ",(0,c.jsx)(s.code,{children:"10"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_INFLUXDB2_TOKEN"}),":",(0,c.jsx)(s.br,{}),"\n","InfluxDB v2 access token."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP"}),":",(0,c.jsx)(s.br,{}),"\n","OpenTelemetry metrics exporter type. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_ADDENTRYPOINTSLABELS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable metrics on entry points. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_ADDROUTERSLABELS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable metrics on routers. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_ADDSERVICESLABELS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable metrics on services. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_EXPLICITBOUNDARIES"}),":",(0,c.jsx)(s.br,{}),"\n","Boundaries for latency metrics. (Default: ",(0,c.jsx)(s.code,{children:"0.005000, 0.010000, 0.025000, 0.050000, 0.075000, 0.100000, 0.250000, 0.500000, 0.750000, 1.000000, 2.500000, 5.000000, 7.500000, 10.000000"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_GRPC"}),":",(0,c.jsx)(s.br,{}),"\n","gRPC configuration for the OpenTelemetry collector. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_GRPC_ENDPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","Sets the gRPC endpoint (host",":port",") of the collector. (Default: ",(0,c.jsx)(s.code,{children:"localhost:4317"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_GRPC_HEADERS_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Headers sent with payload."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_GRPC_INSECURE"}),":",(0,c.jsx)(s.br,{}),"\n","Disables client transport security for the exporter. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_GRPC_TLS_CA"}),":",(0,c.jsx)(s.br,{}),"\n","TLS CA"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_GRPC_TLS_CERT"}),":",(0,c.jsx)(s.br,{}),"\n","TLS cert"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_GRPC_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS insecure skip verify (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_GRPC_TLS_KEY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS key"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_HTTP"}),":",(0,c.jsx)(s.br,{}),"\n","HTTP configuration for the OpenTelemetry collector. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_HTTP_ENDPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","Sets the HTTP endpoint (scheme://host",":port","/path) of the collector. (Default: ",(0,c.jsx)(s.code,{children:"https://localhost:4318"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_HTTP_HEADERS_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Headers sent with payload."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_HTTP_TLS_CA"}),":",(0,c.jsx)(s.br,{}),"\n","TLS CA"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_HTTP_TLS_CERT"}),":",(0,c.jsx)(s.br,{}),"\n","TLS cert"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_HTTP_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS insecure skip verify (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_HTTP_TLS_KEY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS key"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_PUSHINTERVAL"}),":",(0,c.jsx)(s.br,{}),"\n","Period between calls to collect a checkpoint. (Default: ",(0,c.jsx)(s.code,{children:"10"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_OTLP_SERVICENAME"}),":",(0,c.jsx)(s.br,{}),"\n","OTEL service name to use. (Default: ",(0,c.jsx)(s.code,{children:"Mesh"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_PROMETHEUS"}),":",(0,c.jsx)(s.br,{}),"\n","Prometheus metrics exporter type. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_PROMETHEUS_ADDENTRYPOINTSLABELS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable metrics on entry points. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_PROMETHEUS_ADDROUTERSLABELS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable metrics on routers. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_PROMETHEUS_ADDSERVICESLABELS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable metrics on services. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_PROMETHEUS_BUCKETS"}),":",(0,c.jsx)(s.br,{}),"\n","Buckets for latency metrics. (Default: ",(0,c.jsx)(s.code,{children:"0.100000, 0.300000, 1.200000, 5.000000"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_PROMETHEUS_ENTRYPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","EntryPoint (Default: ",(0,c.jsx)(s.code,{children:"Mesh"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_PROMETHEUS_HEADERLABELS_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Defines the extra labels for the requests_total metrics, and for each of them, the request header containing the value for this label."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_PROMETHEUS_MANUALROUTING"}),":",(0,c.jsx)(s.br,{}),"\n","Manual routing (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_STATSD"}),":",(0,c.jsx)(s.br,{}),"\n","StatsD metrics exporter type. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_STATSD_ADDENTRYPOINTSLABELS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable metrics on entry points. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_STATSD_ADDRESS"}),":",(0,c.jsx)(s.br,{}),"\n","StatsD address. (Default: ",(0,c.jsx)(s.code,{children:"localhost:8125"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_STATSD_ADDROUTERSLABELS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable metrics on routers. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_STATSD_ADDSERVICESLABELS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable metrics on services. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_STATSD_PREFIX"}),":",(0,c.jsx)(s.br,{}),"\n","Prefix to use for metrics collection. (Default: ",(0,c.jsx)(s.code,{children:"Mesh"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_METRICS_STATSD_PUSHINTERVAL"}),":",(0,c.jsx)(s.br,{}),"\n","StatsD push interval. (Default: ",(0,c.jsx)(s.code,{children:"10"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PING"}),":",(0,c.jsx)(s.br,{}),"\n","Enable ping. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PING_ENTRYPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","EntryPoint (Default: ",(0,c.jsx)(s.code,{children:"Mesh"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PING_MANUALROUTING"}),":",(0,c.jsx)(s.br,{}),"\n","Manual routing (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PING_TERMINATINGSTATUSCODE"}),":",(0,c.jsx)(s.br,{}),"\n","Terminating status code (Default: ",(0,c.jsx)(s.code,{children:"503"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSUL"}),":",(0,c.jsx)(s.br,{}),"\n","Enable Consul backend with default settings. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG"}),":",(0,c.jsx)(s.br,{}),"\n","Enable ConsulCatalog backend with default settings. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_CACHE"}),":",(0,c.jsx)(s.br,{}),"\n","Use local agent caching for catalog reads. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_CONNECTAWARE"}),":",(0,c.jsx)(s.br,{}),"\n","Enable Consul Connect support. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_CONNECTBYDEFAULT"}),":",(0,c.jsx)(s.br,{}),"\n","Consider every service as Connect capable by default. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_CONSTRAINTS"}),":",(0,c.jsx)(s.br,{}),"\n","Constraints is an expression that Mesh matches against the container's labels to determine whether to create any route for that container."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_DEFAULTRULE"}),":",(0,c.jsx)(s.br,{}),"\n","Default rule. (Default: ",(0,c.jsx)(s.code,{children:"Host(`{{ normalize .Name }}`)"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_ENDPOINT_ADDRESS"}),":",(0,c.jsx)(s.br,{}),"\n","The address of the Consul server"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_ENDPOINT_DATACENTER"}),":",(0,c.jsx)(s.br,{}),"\n","Data center to use. If not provided, the default agent data center is used"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_ENDPOINT_ENDPOINTWAITTIME"}),":",(0,c.jsx)(s.br,{}),"\n","WaitTime limits how long a Watch will block. If not provided, the agent default values will be used (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_ENDPOINT_HTTPAUTH_PASSWORD"}),":",(0,c.jsx)(s.br,{}),"\n","Basic Auth password"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_ENDPOINT_HTTPAUTH_USERNAME"}),":",(0,c.jsx)(s.br,{}),"\n","Basic Auth username"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_ENDPOINT_SCHEME"}),":",(0,c.jsx)(s.br,{}),"\n","The URI scheme for the Consul server"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_ENDPOINT_TLS_CA"}),":",(0,c.jsx)(s.br,{}),"\n","TLS CA"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_ENDPOINT_TLS_CERT"}),":",(0,c.jsx)(s.br,{}),"\n","TLS cert"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_ENDPOINT_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS insecure skip verify (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_ENDPOINT_TLS_KEY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS key"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_ENDPOINT_TOKEN"}),":",(0,c.jsx)(s.br,{}),"\n","Token is used to provide a per-request ACL token which overrides the agent's default token"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_EXPOSEDBYDEFAULT"}),":",(0,c.jsx)(s.br,{}),"\n","Expose containers by default. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_NAMESPACES"}),":",(0,c.jsx)(s.br,{}),"\n","Sets the namespaces used to discover services (Consul Enterprise only)."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_PREFIX"}),":",(0,c.jsx)(s.br,{}),"\n","Prefix for consul service tags. (Default: ",(0,c.jsx)(s.code,{children:"Mesh"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_REFRESHINTERVAL"}),":",(0,c.jsx)(s.br,{}),"\n","Interval for check Consul API. (Default: ",(0,c.jsx)(s.code,{children:"15"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_REQUIRECONSISTENT"}),":",(0,c.jsx)(s.br,{}),"\n","Forces the read to be fully consistent. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_SERVICENAME"}),":",(0,c.jsx)(s.br,{}),"\n","Name of the Mesh service in Consul Catalog (needs to be registered via the orchestrator or manually). (Default: ",(0,c.jsx)(s.code,{children:"Mesh"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_STALE"}),":",(0,c.jsx)(s.br,{}),"\n","Use stale consistency for catalog reads. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_STRICTCHECKS"}),":",(0,c.jsx)(s.br,{}),"\n","A list of service health statuses to allow taking traffic. (Default: ",(0,c.jsx)(s.code,{children:"passing, warning"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSULCATALOG_WATCH"}),":",(0,c.jsx)(s.br,{}),"\n","Watch Consul API events. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSUL_ENDPOINTS"}),":",(0,c.jsx)(s.br,{}),"\n","KV store endpoints. (Default: ",(0,c.jsx)(s.code,{children:"127.0.0.1:8500"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSUL_NAMESPACES"}),":",(0,c.jsx)(s.br,{}),"\n","Sets the namespaces used to discover the configuration (Consul Enterprise only)."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSUL_ROOTKEY"}),":",(0,c.jsx)(s.br,{}),"\n","Root key used for KV store. (Default: ",(0,c.jsx)(s.code,{children:"Mesh"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSUL_TLS_CA"}),":",(0,c.jsx)(s.br,{}),"\n","TLS CA"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSUL_TLS_CERT"}),":",(0,c.jsx)(s.br,{}),"\n","TLS cert"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSUL_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS insecure skip verify (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSUL_TLS_KEY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS key"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_CONSUL_TOKEN"}),":",(0,c.jsx)(s.br,{}),"\n","Per-request ACL token."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_DOCKER"}),":",(0,c.jsx)(s.br,{}),"\n","Enable Docker backend with default settings. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_DOCKER_ALLOWEMPTYSERVICES"}),":",(0,c.jsx)(s.br,{}),"\n","Disregards the Docker containers health checks with respect to the creation or removal of the corresponding services. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_DOCKER_CONSTRAINTS"}),":",(0,c.jsx)(s.br,{}),"\n","Constraints is an expression that Mesh matches against the container's labels to determine whether to create any route for that container."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_DOCKER_DEFAULTRULE"}),":",(0,c.jsx)(s.br,{}),"\n","Default rule. (Default: ",(0,c.jsx)(s.code,{children:"Host(`{{ normalize .Name }}`)"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_DOCKER_ENDPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","Docker server endpoint. Can be a TCP or a Unix socket endpoint. (Default: ",(0,c.jsx)(s.code,{children:"unix:///var/run/docker.sock"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_DOCKER_EXPOSEDBYDEFAULT"}),":",(0,c.jsx)(s.br,{}),"\n","Expose containers by default. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_DOCKER_HTTPCLIENTTIMEOUT"}),":",(0,c.jsx)(s.br,{}),"\n","Client timeout for HTTP connections. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_DOCKER_NETWORK"}),":",(0,c.jsx)(s.br,{}),"\n","Default Docker network used."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_DOCKER_PASSWORD"}),":",(0,c.jsx)(s.br,{}),"\n","Password for Basic HTTP authentication."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_DOCKER_TLS_CA"}),":",(0,c.jsx)(s.br,{}),"\n","TLS CA"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_DOCKER_TLS_CERT"}),":",(0,c.jsx)(s.br,{}),"\n","TLS cert"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_DOCKER_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS insecure skip verify (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_DOCKER_TLS_KEY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS key"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_DOCKER_USEBINDPORTIP"}),":",(0,c.jsx)(s.br,{}),"\n","Use the ip address from the bound port, rather than from the inner network. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_DOCKER_USERNAME"}),":",(0,c.jsx)(s.br,{}),"\n","Username for Basic HTTP authentication."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_DOCKER_WATCH"}),":",(0,c.jsx)(s.br,{}),"\n","Watch Docker events. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ECS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable AWS ECS backend with default settings. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ECS_ACCESSKEYID"}),":",(0,c.jsx)(s.br,{}),"\n","AWS credentials access key ID to use for making requests."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ECS_AUTODISCOVERCLUSTERS"}),":",(0,c.jsx)(s.br,{}),"\n","Auto discover cluster. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ECS_CLUSTERS"}),":",(0,c.jsx)(s.br,{}),"\n","ECS Cluster names. (Default: ",(0,c.jsx)(s.code,{children:"default"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ECS_CONSTRAINTS"}),":",(0,c.jsx)(s.br,{}),"\n","Constraints is an expression that Mesh matches against the container's labels to determine whether to create any route for that container."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ECS_DEFAULTRULE"}),":",(0,c.jsx)(s.br,{}),"\n","Default rule. (Default: ",(0,c.jsx)(s.code,{children:"Host(`{{ normalize .Name }}`)"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ECS_ECSANYWHERE"}),":",(0,c.jsx)(s.br,{}),"\n","Enable ECS Anywhere support. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ECS_EXPOSEDBYDEFAULT"}),":",(0,c.jsx)(s.br,{}),"\n","Expose services by default. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ECS_HEALTHYTASKSONLY"}),":",(0,c.jsx)(s.br,{}),"\n","Determines whether to discover only healthy tasks. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ECS_REFRESHSECONDS"}),":",(0,c.jsx)(s.br,{}),"\n","Polling interval (in seconds). (Default: ",(0,c.jsx)(s.code,{children:"15"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ECS_REGION"}),":",(0,c.jsx)(s.br,{}),"\n","AWS region to use for requests."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ECS_SECRETACCESSKEY"}),":",(0,c.jsx)(s.br,{}),"\n","AWS credentials access key to use for making requests."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ETCD"}),":",(0,c.jsx)(s.br,{}),"\n","Enable Etcd backend with default settings. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ETCD_ENDPOINTS"}),":",(0,c.jsx)(s.br,{}),"\n","KV store endpoints. (Default: ",(0,c.jsx)(s.code,{children:"127.0.0.1:2379"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ETCD_PASSWORD"}),":",(0,c.jsx)(s.br,{}),"\n","Password for authentication."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ETCD_ROOTKEY"}),":",(0,c.jsx)(s.br,{}),"\n","Root key used for KV store. (Default: ",(0,c.jsx)(s.code,{children:"Mesh"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ETCD_TLS_CA"}),":",(0,c.jsx)(s.br,{}),"\n","TLS CA"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ETCD_TLS_CERT"}),":",(0,c.jsx)(s.br,{}),"\n","TLS cert"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ETCD_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS insecure skip verify (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ETCD_TLS_KEY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS key"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ETCD_USERNAME"}),":",(0,c.jsx)(s.br,{}),"\n","Username for authentication."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_FILE_DEBUGLOGGENERATEDTEMPLATE"}),":",(0,c.jsx)(s.br,{}),"\n","Enable debug logging of generated configuration template. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_FILE_DIRECTORY"}),":",(0,c.jsx)(s.br,{}),"\n","Load dynamic configuration from one or more .yml or .toml files in a directory."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_FILE_FILENAME"}),":",(0,c.jsx)(s.br,{}),"\n","Load dynamic configuration from a file."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_FILE_WATCH"}),":",(0,c.jsx)(s.br,{}),"\n","Watch provider. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_HTTP"}),":",(0,c.jsx)(s.br,{}),"\n","Enable HTTP backend with default settings. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_HTTP_ENDPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","Load configuration from this endpoint."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_HTTP_HEADERS_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Define custom headers to be sent to the endpoint."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_HTTP_POLLINTERVAL"}),":",(0,c.jsx)(s.br,{}),"\n","Polling interval for endpoint. (Default: ",(0,c.jsx)(s.code,{children:"5"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_HTTP_POLLTIMEOUT"}),":",(0,c.jsx)(s.br,{}),"\n","Polling timeout for endpoint. (Default: ",(0,c.jsx)(s.code,{children:"5"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_HTTP_TLS_CA"}),":",(0,c.jsx)(s.br,{}),"\n","TLS CA"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_HTTP_TLS_CERT"}),":",(0,c.jsx)(s.br,{}),"\n","TLS cert"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_HTTP_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS insecure skip verify (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_HTTP_TLS_KEY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS key"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESCRD"}),":",(0,c.jsx)(s.br,{}),"\n","Enable Kubernetes backend with default settings. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESCRD_ALLOWCROSSNAMESPACE"}),":",(0,c.jsx)(s.br,{}),"\n","Allow cross namespace resource reference. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESCRD_ALLOWEMPTYSERVICES"}),":",(0,c.jsx)(s.br,{}),"\n","Allow the creation of services without endpoints. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESCRD_ALLOWEXTERNALNAMESERVICES"}),":",(0,c.jsx)(s.br,{}),"\n","Allow ExternalName services. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESCRD_CERTAUTHFILEPATH"}),":",(0,c.jsx)(s.br,{}),"\n","Kubernetes certificate authority file path (not needed for in-cluster client)."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESCRD_DISABLECLUSTERSCOPERESOURCES"}),":",(0,c.jsx)(s.br,{}),"\n","Disables the lookup of cluster scope resources (incompatible with IngressClasses and NodePortLB enabled services). (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESCRD_ENDPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","Kubernetes server endpoint (required for external cluster client)."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESCRD_INGRESSCLASS"}),":",(0,c.jsx)(s.br,{}),"\n","Value of kubernetes.io/ingress.class annotation to watch for."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESCRD_LABELSELECTOR"}),":",(0,c.jsx)(s.br,{}),"\n","Kubernetes label selector to use."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESCRD_NAMESPACES"}),":",(0,c.jsx)(s.br,{}),"\n","Kubernetes namespaces."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESCRD_NATIVELBBYDEFAULT"}),":",(0,c.jsx)(s.br,{}),"\n","Defines whether to use Native Kubernetes load-balancing mode by default. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESCRD_THROTTLEDURATION"}),":",(0,c.jsx)(s.br,{}),"\n","Ingress refresh throttle duration (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESCRD_TOKEN"}),":",(0,c.jsx)(s.br,{}),"\n","Kubernetes bearer token (not needed for in-cluster client). It accepts either a token value or a file path to the token."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESGATEWAY"}),":",(0,c.jsx)(s.br,{}),"\n","Enable Kubernetes gateway api provider with default settings. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESGATEWAY_CERTAUTHFILEPATH"}),":",(0,c.jsx)(s.br,{}),"\n","Kubernetes certificate authority file path (not needed for in-cluster client)."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESGATEWAY_ENDPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","Kubernetes server endpoint (required for external cluster client)."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESGATEWAY_EXPERIMENTALCHANNEL"}),":",(0,c.jsx)(s.br,{}),"\n","Toggles Experimental Channel resources support (TCPRoute, TLSRoute...). (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESGATEWAY_LABELSELECTOR"}),":",(0,c.jsx)(s.br,{}),"\n","Kubernetes label selector to select specific GatewayClasses."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESGATEWAY_NAMESPACES"}),":",(0,c.jsx)(s.br,{}),"\n","Kubernetes namespaces."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESGATEWAY_NATIVELBBYDEFAULT"}),":",(0,c.jsx)(s.br,{}),"\n","Defines whether to use Native Kubernetes load-balancing by default. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESGATEWAY_STATUSADDRESS_HOSTNAME"}),":",(0,c.jsx)(s.br,{}),"\n","Hostname used for Kubernetes Gateway status address."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESGATEWAY_STATUSADDRESS_IP"}),":",(0,c.jsx)(s.br,{}),"\n","IP used to set Kubernetes Gateway status address."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESGATEWAY_STATUSADDRESS_SERVICE"}),":",(0,c.jsx)(s.br,{}),"\n","Published Kubernetes Service to copy status addresses from."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESGATEWAY_STATUSADDRESS_SERVICE_NAME"}),":",(0,c.jsx)(s.br,{}),"\n","Name of the Kubernetes service."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESGATEWAY_STATUSADDRESS_SERVICE_NAMESPACE"}),":",(0,c.jsx)(s.br,{}),"\n","Namespace of the Kubernetes service."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESGATEWAY_THROTTLEDURATION"}),":",(0,c.jsx)(s.br,{}),"\n","Kubernetes refresh throttle duration (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESGATEWAY_TOKEN"}),":",(0,c.jsx)(s.br,{}),"\n","Kubernetes bearer token (not needed for in-cluster client). It accepts either a token value or a file path to the token."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESINGRESS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable Kubernetes backend with default settings. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESINGRESS_ALLOWEMPTYSERVICES"}),":",(0,c.jsx)(s.br,{}),"\n","Allow creation of services without endpoints. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESINGRESS_ALLOWEXTERNALNAMESERVICES"}),":",(0,c.jsx)(s.br,{}),"\n","Allow ExternalName services. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESINGRESS_CERTAUTHFILEPATH"}),":",(0,c.jsx)(s.br,{}),"\n","Kubernetes certificate authority file path (not needed for in-cluster client)."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESINGRESS_DISABLECLUSTERSCOPERESOURCES"}),":",(0,c.jsx)(s.br,{}),"\n","Disables the lookup of cluster scope resources (incompatible with IngressClasses and NodePortLB enabled services). (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESINGRESS_DISABLEINGRESSCLASSLOOKUP"}),":",(0,c.jsx)(s.br,{}),"\n","Disables the lookup of IngressClasses (Deprecated, please use DisableClusterScopeResources). (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESINGRESS_ENDPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","Kubernetes server endpoint (required for external cluster client)."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESINGRESS_INGRESSCLASS"}),":",(0,c.jsx)(s.br,{}),"\n","Value of kubernetes.io/ingress.class annotation or IngressClass name to watch for."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESINGRESS_INGRESSENDPOINT_HOSTNAME"}),":",(0,c.jsx)(s.br,{}),"\n","Hostname used for Kubernetes Ingress endpoints."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESINGRESS_INGRESSENDPOINT_IP"}),":",(0,c.jsx)(s.br,{}),"\n","IP used for Kubernetes Ingress endpoints."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESINGRESS_INGRESSENDPOINT_PUBLISHEDSERVICE"}),":",(0,c.jsx)(s.br,{}),"\n","Published Kubernetes Service to copy status from."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESINGRESS_LABELSELECTOR"}),":",(0,c.jsx)(s.br,{}),"\n","Kubernetes Ingress label selector to use."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESINGRESS_NAMESPACES"}),":",(0,c.jsx)(s.br,{}),"\n","Kubernetes namespaces."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESINGRESS_NATIVELBBYDEFAULT"}),":",(0,c.jsx)(s.br,{}),"\n","Defines whether to use Native Kubernetes load-balancing mode by default. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESINGRESS_THROTTLEDURATION"}),":",(0,c.jsx)(s.br,{}),"\n","Ingress refresh throttle duration (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_KUBERNETESINGRESS_TOKEN"}),":",(0,c.jsx)(s.br,{}),"\n","Kubernetes bearer token (not needed for in-cluster client). It accepts either a token value or a file path to the token."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD"}),":",(0,c.jsx)(s.br,{}),"\n","Enable Nomad backend with default settings. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_ALLOWEMPTYSERVICES"}),":",(0,c.jsx)(s.br,{}),"\n","Allow the creation of services without endpoints. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_CONSTRAINTS"}),":",(0,c.jsx)(s.br,{}),"\n","Constraints is an expression that Mesh matches against the Nomad service's tags to determine whether to create route(s) for that service."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_DEFAULTRULE"}),":",(0,c.jsx)(s.br,{}),"\n","Default rule. (Default: ",(0,c.jsx)(s.code,{children:"Host(`{{ normalize .Name }}`)"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_ENDPOINT_ADDRESS"}),":",(0,c.jsx)(s.br,{}),"\n","The address of the Nomad server, including scheme and port. (Default: ",(0,c.jsx)(s.code,{children:"http://127.0.0.1:4646"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_ENDPOINT_ENDPOINTWAITTIME"}),":",(0,c.jsx)(s.br,{}),"\n","WaitTime limits how long a Watch will block. If not provided, the agent default values will be used (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_ENDPOINT_REGION"}),":",(0,c.jsx)(s.br,{}),"\n","Nomad region to use. If not provided, the local agent region is used."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_ENDPOINT_TLS_CA"}),":",(0,c.jsx)(s.br,{}),"\n","TLS CA"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_ENDPOINT_TLS_CERT"}),":",(0,c.jsx)(s.br,{}),"\n","TLS cert"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_ENDPOINT_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS insecure skip verify (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_ENDPOINT_TLS_KEY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS key"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_ENDPOINT_TOKEN"}),":",(0,c.jsx)(s.br,{}),"\n","Token is used to provide a per-request ACL token."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_EXPOSEDBYDEFAULT"}),":",(0,c.jsx)(s.br,{}),"\n","Expose Nomad services by default. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_NAMESPACES"}),":",(0,c.jsx)(s.br,{}),"\n","Sets the Nomad namespaces used to discover services."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_PREFIX"}),":",(0,c.jsx)(s.br,{}),"\n","Prefix for nomad service tags. (Default: ",(0,c.jsx)(s.code,{children:"Mesh"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_REFRESHINTERVAL"}),":",(0,c.jsx)(s.br,{}),"\n","Interval for polling Nomad API. (Default: ",(0,c.jsx)(s.code,{children:"15"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_STALE"}),":",(0,c.jsx)(s.br,{}),"\n","Use stale consistency for catalog reads. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_THROTTLEDURATION"}),":",(0,c.jsx)(s.br,{}),"\n","Watch throttle duration. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_NOMAD_WATCH"}),":",(0,c.jsx)(s.br,{}),"\n","Watch Nomad Service events. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_PLUGIN_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Plugins configuration."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_PROVIDERSTHROTTLEDURATION"}),":",(0,c.jsx)(s.br,{}),"\n","Backends throttle duration: minimum duration between 2 events from providers before applying a new configuration. It avoids unnecessary reloads if multiples events are sent in a short amount of time. (Default: ",(0,c.jsx)(s.code,{children:"2"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS"}),":",(0,c.jsx)(s.br,{}),"\n","Enable Redis backend with default settings. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS_DB"}),":",(0,c.jsx)(s.br,{}),"\n","Database to be selected after connecting to the server. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS_ENDPOINTS"}),":",(0,c.jsx)(s.br,{}),"\n","KV store endpoints. (Default: ",(0,c.jsx)(s.code,{children:"127.0.0.1:6379"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS_PASSWORD"}),":",(0,c.jsx)(s.br,{}),"\n","Password for authentication."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS_ROOTKEY"}),":",(0,c.jsx)(s.br,{}),"\n","Root key used for KV store. (Default: ",(0,c.jsx)(s.code,{children:"Mesh"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS_SENTINEL_LATENCYSTRATEGY"}),":",(0,c.jsx)(s.br,{}),"\n","Defines whether to route commands to the closest master or replica nodes (mutually exclusive with RandomStrategy and ReplicaStrategy). (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS_SENTINEL_MASTERNAME"}),":",(0,c.jsx)(s.br,{}),"\n","Name of the master."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS_SENTINEL_PASSWORD"}),":",(0,c.jsx)(s.br,{}),"\n","Password for Sentinel authentication."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS_SENTINEL_RANDOMSTRATEGY"}),":",(0,c.jsx)(s.br,{}),"\n","Defines whether to route commands randomly to master or replica nodes (mutually exclusive with LatencyStrategy and ReplicaStrategy). (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS_SENTINEL_REPLICASTRATEGY"}),":",(0,c.jsx)(s.br,{}),"\n","Defines whether to route all commands to replica nodes (mutually exclusive with LatencyStrategy and RandomStrategy). (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS_SENTINEL_USEDISCONNECTEDREPLICAS"}),":",(0,c.jsx)(s.br,{}),"\n","Use replicas disconnected with master when cannot get connected replicas. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS_SENTINEL_USERNAME"}),":",(0,c.jsx)(s.br,{}),"\n","Username for Sentinel authentication."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS_TLS_CA"}),":",(0,c.jsx)(s.br,{}),"\n","TLS CA"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS_TLS_CERT"}),":",(0,c.jsx)(s.br,{}),"\n","TLS cert"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS insecure skip verify (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS_TLS_KEY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS key"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REDIS_USERNAME"}),":",(0,c.jsx)(s.br,{}),"\n","Username for authentication."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REST"}),":",(0,c.jsx)(s.br,{}),"\n","Enable Rest backend with default settings. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_REST_INSECURE"}),":",(0,c.jsx)(s.br,{}),"\n","Activate REST Provider directly on the entryPoint named Mesh. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM"}),":",(0,c.jsx)(s.br,{}),"\n","Enable Docker Swarm backend with default settings. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM_ALLOWEMPTYSERVICES"}),":",(0,c.jsx)(s.br,{}),"\n","Disregards the Docker containers health checks with respect to the creation or removal of the corresponding services. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM_CONSTRAINTS"}),":",(0,c.jsx)(s.br,{}),"\n","Constraints is an expression that Mesh matches against the container's labels to determine whether to create any route for that container."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM_DEFAULTRULE"}),":",(0,c.jsx)(s.br,{}),"\n","Default rule. (Default: ",(0,c.jsx)(s.code,{children:"Host(`{{ normalize .Name }}`)"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM_ENDPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","Docker server endpoint. Can be a TCP or a Unix socket endpoint. (Default: ",(0,c.jsx)(s.code,{children:"unix:///var/run/docker.sock"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM_EXPOSEDBYDEFAULT"}),":",(0,c.jsx)(s.br,{}),"\n","Expose containers by default. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM_HTTPCLIENTTIMEOUT"}),":",(0,c.jsx)(s.br,{}),"\n","Client timeout for HTTP connections. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM_NETWORK"}),":",(0,c.jsx)(s.br,{}),"\n","Default Docker network used."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM_PASSWORD"}),":",(0,c.jsx)(s.br,{}),"\n","Password for Basic HTTP authentication."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM_REFRESHSECONDS"}),":",(0,c.jsx)(s.br,{}),"\n","Polling interval for swarm mode. (Default: ",(0,c.jsx)(s.code,{children:"15"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM_TLS_CA"}),":",(0,c.jsx)(s.br,{}),"\n","TLS CA"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM_TLS_CERT"}),":",(0,c.jsx)(s.br,{}),"\n","TLS cert"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS insecure skip verify (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM_TLS_KEY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS key"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM_USEBINDPORTIP"}),":",(0,c.jsx)(s.br,{}),"\n","Use the ip address from the bound port, rather than from the inner network. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM_USERNAME"}),":",(0,c.jsx)(s.br,{}),"\n","Username for Basic HTTP authentication."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_SWARM_WATCH"}),":",(0,c.jsx)(s.br,{}),"\n","Watch Docker events. (Default: ",(0,c.jsx)(s.code,{children:"true"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ZOOKEEPER"}),":",(0,c.jsx)(s.br,{}),"\n","Enable ZooKeeper backend with default settings. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ZOOKEEPER_ENDPOINTS"}),":",(0,c.jsx)(s.br,{}),"\n","KV store endpoints. (Default: ",(0,c.jsx)(s.code,{children:"127.0.0.1:2181"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ZOOKEEPER_PASSWORD"}),":",(0,c.jsx)(s.br,{}),"\n","Password for authentication."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ZOOKEEPER_ROOTKEY"}),":",(0,c.jsx)(s.br,{}),"\n","Root key used for KV store. (Default: ",(0,c.jsx)(s.code,{children:"Mesh"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_PROVIDERS_ZOOKEEPER_USERNAME"}),":",(0,c.jsx)(s.br,{}),"\n","Username for authentication."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_SERVERSTRANSPORT_FORWARDINGTIMEOUTS_DIALTIMEOUT"}),":",(0,c.jsx)(s.br,{}),"\n","The amount of time to wait until a connection to a backend server can be established. If zero, no timeout exists. (Default: ",(0,c.jsx)(s.code,{children:"30"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_SERVERSTRANSPORT_FORWARDINGTIMEOUTS_IDLECONNTIMEOUT"}),":",(0,c.jsx)(s.br,{}),"\n","The maximum period for which an idle HTTP keep-alive connection will remain open before closing itself (Default: ",(0,c.jsx)(s.code,{children:"90"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_SERVERSTRANSPORT_FORWARDINGTIMEOUTS_RESPONSEHEADERTIMEOUT"}),":",(0,c.jsx)(s.br,{}),"\n","The amount of time to wait for a server's response headers after fully writing the request (including its body, if any). If zero, no timeout exists. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_SERVERSTRANSPORT_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","Disable SSL certificate verification. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_SERVERSTRANSPORT_MAXIDLECONNSPERHOST"}),":",(0,c.jsx)(s.br,{}),"\n","If non-zero, controls the maximum idle (keep-alive) to keep per-host. If zero, DefaultMaxIdleConnsPerHost is used (Default: ",(0,c.jsx)(s.code,{children:"200"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_SERVERSTRANSPORT_ROOTCAS"}),":",(0,c.jsx)(s.br,{}),"\n","Add cert file for self-signed certificate."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_SERVERSTRANSPORT_SPIFFE"}),":",(0,c.jsx)(s.br,{}),"\n","Defines the SPIFFE configuration. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_SERVERSTRANSPORT_SPIFFE_IDS"}),":",(0,c.jsx)(s.br,{}),"\n","Defines the allowed SPIFFE IDs (takes precedence over the SPIFFE TrustDomain)."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_SERVERSTRANSPORT_SPIFFE_TRUSTDOMAIN"}),":",(0,c.jsx)(s.br,{}),"\n","Defines the allowed SPIFFE trust domain."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_SPIFFE_WORKLOADAPIADDR"}),":",(0,c.jsx)(s.br,{}),"\n","Defines the workload API address."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TCPSERVERSTRANSPORT_DIALKEEPALIVE"}),":",(0,c.jsx)(s.br,{}),"\n","Defines the interval between keep-alive probes for an active network connection. If zero, keep-alive probes are sent with a default value (currently 15 seconds), if supported by the protocol and operating system. Network protocols or operating systems that do not support keep-alives ignore this field. If negative, keep-alive probes are disabled (Default: ",(0,c.jsx)(s.code,{children:"15"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TCPSERVERSTRANSPORT_DIALTIMEOUT"}),":",(0,c.jsx)(s.br,{}),"\n","Defines the amount of time to wait until a connection to a backend server can be established. If zero, no timeout exists. (Default: ",(0,c.jsx)(s.code,{children:"30"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TCPSERVERSTRANSPORT_TERMINATIONDELAY"}),":",(0,c.jsx)(s.br,{}),"\n","Defines the delay to wait before fully terminating the connection, after one connected peer has closed its writing capability. (Default: ",(0,c.jsx)(s.code,{children:"0"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TCPSERVERSTRANSPORT_TLS"}),":",(0,c.jsx)(s.br,{}),"\n","Defines the TLS configuration. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TCPSERVERSTRANSPORT_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","Disables SSL certificate verification. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TCPSERVERSTRANSPORT_TLS_ROOTCAS"}),":",(0,c.jsx)(s.br,{}),"\n","Defines a list of CA secret used to validate self-signed certificate"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TCPSERVERSTRANSPORT_TLS_SPIFFE"}),":",(0,c.jsx)(s.br,{}),"\n","Defines the SPIFFE TLS configuration. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TCPSERVERSTRANSPORT_TLS_SPIFFE_IDS"}),":",(0,c.jsx)(s.br,{}),"\n","Defines the allowed SPIFFE IDs (takes precedence over the SPIFFE TrustDomain)."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TCPSERVERSTRANSPORT_TLS_SPIFFE_TRUSTDOMAIN"}),":",(0,c.jsx)(s.br,{}),"\n","Defines the allowed SPIFFE trust domain."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING"}),":",(0,c.jsx)(s.br,{}),"\n","Tracing configuration. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_ADDINTERNALS"}),":",(0,c.jsx)(s.br,{}),"\n","Enables tracing for internal services (ping, dashboard, etc...). (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_CAPTUREDREQUESTHEADERS"}),":",(0,c.jsx)(s.br,{}),"\n","Request headers to add as attributes for server and client spans."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_CAPTUREDRESPONSEHEADERS"}),":",(0,c.jsx)(s.br,{}),"\n","Response headers to add as attributes for server and client spans."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_GLOBALATTRIBUTES_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","(Deprecated) Defines additional resource attributes (key",":value",")."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_OTLP"}),":",(0,c.jsx)(s.br,{}),"\n","Settings for OpenTelemetry. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_OTLP_GRPC"}),":",(0,c.jsx)(s.br,{}),"\n","gRPC configuration for the OpenTelemetry collector. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_OTLP_GRPC_ENDPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","Sets the gRPC endpoint (host",":port",") of the collector. (Default: ",(0,c.jsx)(s.code,{children:"localhost:4317"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_OTLP_GRPC_HEADERS_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Headers sent with payload."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_OTLP_GRPC_INSECURE"}),":",(0,c.jsx)(s.br,{}),"\n","Disables client transport security for the exporter. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_OTLP_GRPC_TLS_CA"}),":",(0,c.jsx)(s.br,{}),"\n","TLS CA"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_OTLP_GRPC_TLS_CERT"}),":",(0,c.jsx)(s.br,{}),"\n","TLS cert"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_OTLP_GRPC_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS insecure skip verify (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_OTLP_GRPC_TLS_KEY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS key"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_OTLP_HTTP"}),":",(0,c.jsx)(s.br,{}),"\n","HTTP configuration for the OpenTelemetry collector. (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_OTLP_HTTP_ENDPOINT"}),":",(0,c.jsx)(s.br,{}),"\n","Sets the HTTP endpoint (scheme://host",":port","/path) of the collector. (Default: ",(0,c.jsx)(s.code,{children:"https://localhost:4318"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_OTLP_HTTP_HEADERS_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Headers sent with payload."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_OTLP_HTTP_TLS_CA"}),":",(0,c.jsx)(s.br,{}),"\n","TLS CA"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_OTLP_HTTP_TLS_CERT"}),":",(0,c.jsx)(s.br,{}),"\n","TLS cert"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_OTLP_HTTP_TLS_INSECURESKIPVERIFY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS insecure skip verify (Default: ",(0,c.jsx)(s.code,{children:"false"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_OTLP_HTTP_TLS_KEY"}),":",(0,c.jsx)(s.br,{}),"\n","TLS key"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_RESOURCEATTRIBUTES_<NAME>"}),":",(0,c.jsx)(s.br,{}),"\n","Defines additional resource attributes (key",":value",")."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_SAFEQUERYPARAMS"}),":",(0,c.jsx)(s.br,{}),"\n","Query params to not redact."]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_SAMPLERATE"}),":",(0,c.jsx)(s.br,{}),"\n","Sets the rate between 0.0 and 1.0 of requests to trace. (Default: ",(0,c.jsx)(s.code,{children:"1.000000"}),")"]}),"\n",(0,c.jsxs)(s.p,{children:[(0,c.jsx)(s.code,{children:"Mesh_TRACING_SERVICENAME"}),":",(0,c.jsx)(s.br,{}),"\n","Sets the name for this service. (Default: ",(0,c.jsx)(s.code,{children:"Mesh"}),")"]})]})}function E(e={}){const{wrapper:s}={...(0,d.R)(),...e.components};return s?(0,c.jsx)(s,{...e,children:(0,c.jsx)(t,{...e})}):t(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>l,x:()=>i});var r=n(6540);const c={},d=r.createContext(c);function l(e){const s=r.useContext(d);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:l(e.components),r.createElement(d.Provider,{value:s},e.children)}}}]);