"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[7156],{3287:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"reference/install-configuration/entrypoints","title":"Mesh EntryPoints Documentation","description":"For routing and load balancing in Mesh Proxy, EntryPoints define which port will receive packets and whether they are TCP or UDP. Read the technical documentation.","source":"@site/docs/reference/install-configuration/entrypoints.md","sourceDirName":"reference/install-configuration","slug":"/reference/install-configuration/entrypoints","permalink":"/doc/docs/reference/install-configuration/entrypoints","draft":false,"unlisted":false,"editUrl":"https://github.com/opendatav/mesh/tree/main/packages/create-docusaurus/templates/shared/docs/reference/install-configuration/entrypoints.md","tags":[],"version":"current","frontMatter":{"title":"Mesh EntryPoints Documentation","description":"For routing and load balancing in Mesh Proxy, EntryPoints define which port will receive packets and whether they are TCP or UDP. Read the technical documentation."},"sidebar":"tutorialSidebar","previous":{"title":"cli-options-list","permalink":"/doc/docs/reference/install-configuration/cli-options-list"},"next":{"title":"Mesh Health Check Documentation","permalink":"/doc/docs/reference/install-configuration/observability/healthcheck"}}');var r=n(4848),i=n(8453);const l={title:"Mesh EntryPoints Documentation",description:"For routing and load balancing in Mesh Proxy, EntryPoints define which port will receive packets and whether they are TCP or UDP. Read the technical documentation."},o=void 0,d={},c=[{value:"Configuration Example",id:"configuration-example",level:3},{value:"Configuration Options",id:"configuration-options",level:2},{value:"asDefault",id:"asdefault",level:3},{value:"http.middlewares",id:"httpmiddlewares",level:3},{value:"encodeQuerySemicolons",id:"encodequerysemicolons",level:3},{value:"SanitizePath",id:"sanitizepath",level:3},{value:"Examples",id:"examples",level:4},{value:"HTTP3",id:"http3",level:3},{value:"ProxyProtocol and Load-Balancers",id:"proxyprotocol-and-load-balancers",level:3},{value:"reusePort",id:"reuseport",level:3},{value:"Examples",id:"examples-1",level:4},{value:"Supported platforms",id:"supported-platforms",level:4},{value:"Canary deployment",id:"canary-deployment",level:4}];function a(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"Listening for Incoming Connections/Requests"}),"\n",(0,r.jsx)(t.h3,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="File (YAML)"',children:"entryPoints:\n  web:\n    address: :80\n    http:\n      redirections:\n        entryPoint:\n          to: websecure\n          scheme: https\n          permanent: true\n\n  websecure:\n    address: :443\n    tls: {}\n    middlewares:\n      - auth@kubernetescrd\n      - strip@kubernetescrd\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="Helm Chart Values"',children:"## Values file\nports:\n  web:\n    port: :80\n  websecure:\n    port: :443\n    tls:\n      enabled: true\n    middlewares:\n      - auth@kubernetescrd\n      - strip@kubernetescrd\nadditionalArguments:\n  - --entryPoints.web.http.redirections.to=websecure\n  - --entryPoints.web.http.redirections.scheme=https\n  - --entryPoints.web.http.redirections.permanent=true\n"})}),"\n",(0,r.jsx)(t.p,{children:"!!! tip"}),"\n",(0,r.jsxs)(t.p,{children:["In the Helm Chart, the entryPoints ",(0,r.jsx)(t.code,{children:"web"})," (port 80), ",(0,r.jsx)(t.code,{children:"websecure"})," (port 443), ",(0,r.jsx)(t.code,{children:"Mesh"})," (port 8080) and ",(0,r.jsx)(t.code,{children:"metrics"})," (port 9100) are created by default.\nThe entryPoints ",(0,r.jsx)(t.code,{children:"web"}),", ",(0,r.jsx)(t.code,{children:"websecure"})," are exposed by default using a Service."]}),"\n",(0,r.jsx)(t.p,{children:"The default behaviors can be overridden in the Helm Chart."}),"\n",(0,r.jsx)(t.h2,{id:"configuration-options",children:"Configuration Options"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Field"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Description"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Default"}),(0,r.jsx)(t.th,{style:{textAlign:"left"},children:"Required"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"address"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Define the port, and optionally the hostname, on which to listen for incoming connections and packets.",(0,r.jsx)("br",{})," It also defines the protocol to use (TCP or UDP).",(0,r.jsx)("br",{})," If no protocol is specified, the default is TCP. The format is:",(0,r.jsx)(t.code,{children:"[host]:port[/tcp|/udp]"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"-"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"accessLogs"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Defines whether a router attached to this EntryPoint produces access-logs by default. Nonetheless, a router defining its own observability configuration will opt-out from this default."}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"true"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"asDefault"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Mark the ",(0,r.jsx)(t.code,{children:"entryPoint"})," to be in the list of default ",(0,r.jsx)(t.code,{children:"entryPoints"}),".",(0,r.jsx)("br",{})," ",(0,r.jsx)(t.code,{children:"entryPoints"}),"in this list are used (by default) on HTTP and TCP routers that do not define their own ",(0,r.jsx)(t.code,{children:"entryPoints"})," option.",(0,r.jsx)("br",{})," More information ",(0,r.jsx)(t.a,{href:"#asdefault",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"forwardedHeaders.trustedIPs"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Set the IPs or CIDR from where Mesh trusts the forwarded headers information (",(0,r.jsx)(t.code,{children:"X-Forwarded-*"}),")."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"-"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"forwardedHeaders.insecure"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Set the insecure mode to always trust the forwarded headers information (",(0,r.jsx)(t.code,{children:"X-Forwarded-*"}),").",(0,r.jsx)("br",{}),"We recommend to use this option only for tests purposes, not in production."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"http.redirections."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"entryPoint.to"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["The target element to enable (permanent) redirecting of all incoming requests on an entry point to another one. ",(0,r.jsx)("br",{})," The target element can be an entry point name (ex: ",(0,r.jsx)(t.code,{children:"websecure"}),"), or a port (",(0,r.jsx)(t.code,{children:":443"}),")."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"-"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Yes"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"http.redirections."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"entryPoint.scheme"})]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"The target scheme to use for (permanent) redirection of all incoming requests."}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"https"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"http.redirections."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"entryPoint.permanent"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Enable permanent redirecting of all incoming requests on an entry point to another one changing the scheme. ",(0,r.jsx)("br",{})," The target element, it can be an entry point name (ex: ",(0,r.jsx)(t.code,{children:"websecure"}),"), or a port (",(0,r.jsx)(t.code,{children:":443"}),")."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"http.redirections."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"entryPoint.priority"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Default priority applied to the routers attached to the ",(0,r.jsx)(t.code,{children:"entryPoint"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"MaxInt32-1 (2147483646)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"http.encodeQuerySemicolons"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Enable query semicolons encoding. ",(0,r.jsx)("br",{})," Use this option to avoid non-encoded semicolons to be interpreted as query parameter separators by Mesh. ",(0,r.jsx)("br",{})," When using this option, the non-encoded semicolons characters in query will be transmitted encoded to the backend.",(0,r.jsx)("br",{})," More information ",(0,r.jsx)(t.a,{href:"#encodequerysemicolons",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"http.sanitizePath"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Defines whether to enable the request path sanitization.",(0,r.jsx)("br",{})," More information ",(0,r.jsx)(t.a,{href:"#sanitizepath",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"http.middlewares"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Set the list of middlewares that are prepended by default to the list of middlewares of each router associated to the named entry point. ",(0,r.jsx)("br",{}),"More information ",(0,r.jsx)(t.a,{href:"#httpmiddlewares",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"-"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"http.tls"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Enable TLS on every router attached to the ",(0,r.jsx)(t.code,{children:"entryPoint"}),". ",(0,r.jsx)("br",{})," If no certificate are set, a default self-signed certificate is generates by Mesh. ",(0,r.jsx)("br",{})," We recommend to not use self signed certificates in production."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"-"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"http.tls.options"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Apply TLS options on every router attached to the ",(0,r.jsx)(t.code,{children:"entryPoint"}),". ",(0,r.jsx)("br",{})," The TLS options can be overidden per router. ",(0,r.jsx)("br",{})," More information in the ",(0,r.jsx)(t.a,{href:"/doc/docs/routing/providers/kubernetes-crd#kind-tlsoption",children:"dedicated section"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"-"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"http.tls.certResolver"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Apply a certificate resolver on every router attached to the ",(0,r.jsx)(t.code,{children:"entryPoint"}),". ",(0,r.jsx)("br",{})," The TLS options can be overidden per router. ",(0,r.jsx)("br",{})," More information in the ",(0,r.jsx)(t.a,{href:"/doc/docs/reference/install-configuration/tls/certificate-resolvers/overview",children:"dedicated section"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"-"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"http2.maxConcurrentStreams"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Set the number of concurrent streams per connection that each client is allowed to initiate. ",(0,r.jsx)("br",{})," The value must be greater than zero."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"250"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"http3"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Enable HTTP/3 protocol on the ",(0,r.jsx)(t.code,{children:"entryPoint"}),". ",(0,r.jsx)("br",{})," HTTP/3 requires a TCP ",(0,r.jsx)(t.code,{children:"entryPoint"}),". as HTTP/3 always starts as a TCP connection that then gets upgraded to UDP. In most scenarios, this ",(0,r.jsx)(t.code,{children:"entryPoint"})," is the same as the one used for TLS traffic.",(0,r.jsx)("br",{})," More information [here](#http3."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"-"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"http3.advertisedPort"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Set the UDP port to advertise as the HTTP/3 authority. ",(0,r.jsx)("br",{})," It defaults to the entryPoint's address port. ",(0,r.jsx)("br",{})," It can be used to override the authority in the ",(0,r.jsx)(t.code,{children:"alt-svc"})," header, for example if the public facing port is different from where Mesh is listening."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"-"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"metrics"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Defines whether a router attached to this EntryPoint produces metrics by default. Nonetheless, a router defining its own observability configuration will opt-out from this default."}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"true"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"proxyProtocol.trustedIPs"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Enable PROXY protocol with Trusted IPs. ",(0,r.jsx)("br",{})," Mesh supports ",(0,r.jsx)(t.a,{href:"https://www.haproxy.org/download/2.0/doc/proxy-protocol.txt",children:"PROXY protocol"})," version 1 and 2. ",(0,r.jsx)("br",{})," If PROXY protocol header parsing is enabled for the entry point, this entry point can accept connections with or without PROXY protocol headers. ",(0,r.jsx)("br",{})," If the PROXY protocol header is passed, then the version is determined automatically.",(0,r.jsx)("br",{})," More information ",(0,r.jsx)(t.a,{href:"#proxyprotocol-and-load-balancers",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"-"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"proxyProtocol.insecure"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Enable PROXY protocol trusting every incoming connection. ",(0,r.jsx)("br",{})," Every remote client address will be replaced (",(0,r.jsx)(t.code,{children:"trustedIPs"}),") won't have any effect). ",(0,r.jsx)("br",{})," Mesh supports ",(0,r.jsx)(t.a,{href:"https://www.haproxy.org/download/2.0/doc/proxy-protocol.txt",children:"PROXY protocol"})," version 1 and 2. ",(0,r.jsx)("br",{})," If PROXY protocol header parsing is enabled for the entry point, this entry point can accept connections with or without PROXY protocol headers. ",(0,r.jsx)("br",{})," If the PROXY protocol header is passed, then the version is determined automatically.",(0,r.jsx)("br",{}),"We recommend to use this option only for tests purposes, not in production.",(0,r.jsx)("br",{})," More information ",(0,r.jsx)(t.a,{href:"#proxyprotocol-and-load-balancers",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"-"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"reusePort"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Enable ",(0,r.jsx)(t.code,{children:"entryPoints"})," from the same or different processes listening on the same TCP/UDP port by utilizing the ",(0,r.jsx)(t.code,{children:"SO_REUSEPORT"})," socket option. ",(0,r.jsx)("br",{})," It also allows the kernel to act like a load balancer to distribute incoming connections between entry points..",(0,r.jsx)("br",{})," More information ",(0,r.jsx)(t.a,{href:"#reuseport",children:"here"}),"."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"false"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"tracing"})}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"Defines whether a router attached to this EntryPoint produces traces by default. Nonetheless, a router defining its own observability configuration will opt-out from this default."}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"true"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"transport."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"respondingTimeouts."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"readTimeout"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Set the timeouts for incoming requests to the Mesh instance. This is the maximum duration for reading the entire request, including the body. Setting them has no effect for UDP ",(0,r.jsx)(t.code,{children:"entryPoints"}),".",(0,r.jsx)("br",{})," If zero, no timeout exists. ",(0,r.jsx)("br",{}),"Can be provided in a format supported by ",(0,r.jsx)(t.a,{href:"https://golang.org/pkg/time/#ParseDuration",children:"time.ParseDuration"})," or as raw values (digits).",(0,r.jsx)("br",{}),"If no units are provided, the value is parsed assuming seconds."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"60s (seconds)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"transport."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"respondingTimeouts."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"writeTimeout"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Maximum duration before timing out writes of the response. ",(0,r.jsx)("br",{})," It covers the time from the end of the request header read to the end of the response write. ",(0,r.jsx)("br",{})," If zero, no timeout exists. ",(0,r.jsx)("br",{}),"Can be provided in a format supported by ",(0,r.jsx)(t.a,{href:"https://golang.org/pkg/time/#ParseDuration",children:"time.ParseDuration"})," or as raw values (digits).",(0,r.jsx)("br",{}),"If no units are provided, the value is parsed assuming seconds."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"0s (seconds)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"transport."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"respondingTimeouts."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"idleTimeout"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Maximum duration an idle (keep-alive) connection will remain idle before closing itself. ",(0,r.jsx)("br",{})," If zero, no timeout exists ",(0,r.jsx)("br",{}),"Can be provided in a format supported by ",(0,r.jsx)(t.a,{href:"https://golang.org/pkg/time/#ParseDuration",children:"time.ParseDuration"})," or as raw values (digits).",(0,r.jsx)("br",{}),"If no units are provided, the value is parsed assuming seconds"]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"180s (seconds)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"transport."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"lifeCycle."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"graceTimeOut"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Set the duration to give active requests a chance to finish before Mesh stops. ",(0,r.jsx)("br",{}),"Can be provided in a format supported by ",(0,r.jsx)(t.a,{href:"https://golang.org/pkg/time/#ParseDuration",children:"time.ParseDuration"})," or as raw values (digits).",(0,r.jsx)("br",{}),"If no units are provided, the value is parsed assuming seconds ",(0,r.jsx)("br",{})," In this time frame no new requests are accepted."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"10s (seconds)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"transport."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"lifeCycle."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"requestAcceptGraceTimeout"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Set the duration to keep accepting requests prior to initiating the graceful termination period (as defined by the ",(0,r.jsx)(t.code,{children:"transportlifeCycle.graceTimeOut"})," option). ",(0,r.jsx)("br",{})," This option is meant to give downstream load-balancers sufficient time to take Mesh out of rotation. ",(0,r.jsx)("br",{}),"Can be provided in a format supported by ",(0,r.jsx)(t.a,{href:"https://golang.org/pkg/time/#ParseDuration",children:"time.ParseDuration"})," or as raw values (digits).",(0,r.jsx)("br",{}),"If no units are provided, the value is parsed assuming seconds"]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"0s (seconds)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"transport."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"keepAliveMaxRequests"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Set the maximum number of requests Mesh can handle before sending a ",(0,r.jsx)(t.code,{children:"Connection: Close"})," header to the client (for HTTP2, Mesh sends a GOAWAY). ",(0,r.jsx)("br",{})," Zero means no limit."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"0"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:[(0,r.jsx)(t.code,{children:"transport."}),(0,r.jsx)("br",{}),(0,r.jsx)(t.code,{children:"keepAliveMaxTime"})]}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Set the maximum duration Mesh can handle requests before sending a ",(0,r.jsx)(t.code,{children:"Connection: Close"})," header to the client (for HTTP2, Mesh sends a GOAWAY). Zero means no limit."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"0s (seconds)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{style:{textAlign:"left"},children:(0,r.jsx)(t.code,{children:"udp.timeout"})}),(0,r.jsxs)(t.td,{style:{textAlign:"left"},children:["Define how long to wait on an idle session before releasing the related resources. ",(0,r.jsx)("br",{}),"The Timeout value must be greater than zero."]}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"3s (seconds)"}),(0,r.jsx)(t.td,{style:{textAlign:"left"},children:"No"})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"asdefault",children:"asDefault"}),"\n",(0,r.jsxs)(t.p,{children:["If there is no entryPoint with the ",(0,r.jsx)(t.code,{children:"asDefault"})," option set to ",(0,r.jsx)(t.code,{children:"true"}),", then the\nlist of default entryPoints includes all HTTP/TCP entryPoints."]}),"\n",(0,r.jsxs)(t.p,{children:["If at least one entryPoint has the ",(0,r.jsx)(t.code,{children:"asDefault"})," option set to ",(0,r.jsx)(t.code,{children:"true"}),",\nthen the list of default entryPoints includes only entryPoints that have the\n",(0,r.jsx)(t.code,{children:"asDefault"})," option set to ",(0,r.jsx)(t.code,{children:"true"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Some built-in entryPoints are always excluded from the list, namely: ",(0,r.jsx)(t.code,{children:"Mesh"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"asDefault"})," option has no effect on UDP entryPoints.\nWhen a UDP router does not define the entryPoints option, it is attached to all\navailable UDP entryPoints."]}),"\n",(0,r.jsx)(t.h3,{id:"httpmiddlewares",children:"http.middlewares"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["You can attach a list of ",(0,r.jsx)(t.a,{href:"/doc/docs/middlewares/http/overview",children:"middlewares"}),"\nto each entryPoint."]}),"\n",(0,r.jsx)(t.li,{children:"The middlewares will take effect only if the rule matches, and before forwarding\nthe request to the service."}),"\n",(0,r.jsx)(t.li,{children:"Middlewares are applied in the same order as their declaration."}),"\n",(0,r.jsxs)(t.li,{children:["Middlewares are applied by default to every router exposed through the EntryPoint\n(the Middlewares declared on the ",(0,r.jsx)(t.a,{href:"/doc/docs/routing/routers/#middlewares",children:"IngressRoute"}),"\nor the ",(0,r.jsx)(t.a,{href:"/doc/docs/routing/providers/kubernetes-ingress#on-ingress",children:"Ingress"}),"\nare applied after the ones declared on the Entrypoint)"]}),"\n",(0,r.jsxs)(t.li,{children:["The option allows attaching a list of middleware using the format\n",(0,r.jsx)(t.code,{children:"middlewarename@providername"})," as described in the example below:"]}),"\n"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="File (YAML)"',children:"entryPoints:\n  web:\n    address: :80\n    middlewares:\n      - auth@kubernetescrd\n      - strip@file\n"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="Helm Chart Values"',children:"ports:\n  web:\n    port: :80\n    middlewares:\n      - auth@kubernetescrd\n      - strip@file\n"})}),"\n",(0,r.jsx)(t.h3,{id:"encodequerysemicolons",children:"encodeQuerySemicolons"}),"\n",(0,r.jsx)(t.p,{children:"Behavior examples:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"EncodeQuerySemicolons"}),(0,r.jsx)(t.th,{children:"Request Query"}),(0,r.jsx)(t.th,{children:"Resulting Request Query"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"false"}),(0,r.jsx)(t.td,{children:"foo=bar;baz=bar"}),(0,r.jsx)(t.td,{children:"foo=bar&baz=bar"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"true"}),(0,r.jsx)(t.td,{children:"foo=bar;baz=bar"}),(0,r.jsx)(t.td,{children:"foo=bar%3Bbaz=bar"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"false"}),(0,r.jsx)(t.td,{children:"foo=bar&baz=bar;foo"}),(0,r.jsx)(t.td,{children:"foo=bar&baz=bar&foo"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"true"}),(0,r.jsx)(t.td,{children:"foo=bar&baz=bar;foo"}),(0,r.jsx)(t.td,{children:"foo=bar&baz=bar%3Bfoo"})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"sanitizepath",children:"SanitizePath"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"sanitizePath"})," option defines whether to enable the request path sanitization.\nWhen disabled, the incoming request path is passed to the backend as is.\nThis can be useful when dealing with legacy clients that are not url-encoding data in the request path.\nFor example, as base64 uses the \u201c/\u201d character internally,\nif it's not url encoded,\nit can lead to unsafe routing when the ",(0,r.jsx)(t.code,{children:"sanitizePath"})," option is set to ",(0,r.jsx)(t.code,{children:"false"}),"."]}),"\n",(0,r.jsx)(t.p,{children:'!!! warning "Security"'}),"\n",(0,r.jsx)(t.p,{children:"Setting the sanitizePath option to false is not safe.\nEnsure every request is properly url encoded instead."}),"\n",(0,r.jsx)(t.h4,{id:"examples",children:"Examples"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"SanitizePath"}),(0,r.jsx)(t.th,{children:"Request Path"}),(0,r.jsx)(t.th,{children:"Resulting Request Path"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"false"}),(0,r.jsx)(t.td,{children:"/./foo/bar"}),(0,r.jsx)(t.td,{children:"/./foo/bar"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"true"}),(0,r.jsx)(t.td,{children:"/./foo/bar"}),(0,r.jsx)(t.td,{children:"/foo/bar"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"false"}),(0,r.jsx)(t.td,{children:"/foo/../bar"}),(0,r.jsx)(t.td,{children:"/foo/../bar"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"true"}),(0,r.jsx)(t.td,{children:"/foo/../bar"}),(0,r.jsx)(t.td,{children:"/bar"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"false"}),(0,r.jsx)(t.td,{children:"/foo/bar//"}),(0,r.jsx)(t.td,{children:"/foo/bar//"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"true"}),(0,r.jsx)(t.td,{children:"/foo/bar//"}),(0,r.jsx)(t.td,{children:"/foo/bar/"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"false"}),(0,r.jsx)(t.td,{children:"/./foo/../bar//"}),(0,r.jsx)(t.td,{children:"/./foo/../bar//"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"true"}),(0,r.jsx)(t.td,{children:"/./foo/../bar//"}),(0,r.jsx)(t.td,{children:"/bar/"})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"http3",children:"HTTP3"}),"\n",(0,r.jsxs)(t.p,{children:["As HTTP/3 actually uses UDP, when Mesh is configured with a TCP ",(0,r.jsx)(t.code,{children:"entryPoint"}),"\non port N with HTTP/3 enabled, the underlying HTTP/3 server that is started\nautomatically listens on UDP port N too. As a consequence,\nit means port N cannot be used by another UDP ",(0,r.jsx)(t.code,{children:"entryPoint"}),".\nSince HTTP/3 requires the use of TLS,\nonly routers with TLS enabled will be usable with HTTP/3."]}),"\n",(0,r.jsx)(t.h3,{id:"proxyprotocol-and-load-balancers",children:"ProxyProtocol and Load-Balancers"}),"\n",(0,r.jsxs)(t.p,{children:["The replacement of the remote client address will occur only for IP addresses listed in ",(0,r.jsx)(t.code,{children:"trustedIPs"}),". This is where yo\xe5u specify your load balancer IPs or CIDR ranges."]}),"\n",(0,r.jsx)(t.p,{children:"When queuing Mesh behind another load-balancer, make sure to configure\nPROXY protocol on both sides.\nNot doing so could introduce a security risk in your system (enabling request forgery)."}),"\n",(0,r.jsx)(t.h3,{id:"reuseport",children:"reusePort"}),"\n",(0,r.jsx)(t.h4,{id:"examples-1",children:"Examples"}),"\n",(0,r.jsx)(t.p,{children:"Many processes on the same EntryPoint:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="File (YAML)"',children:'  entryPoints:\n    web:\n      address: ":80"\n      reusePort: true\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="Helm Chart Values"',children:"  ## Values file\n  additionalArguments:\n    - --entryPoints.web.reusePort=true\n"})}),"\n",(0,r.jsx)(t.p,{children:"Many processes on the same EntryPoint on another host:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="File (YAML)"',children:'entryPoints:\n  web:\n    address: ":80"\n    reusePort: true\n  privateWeb:\n    address: "192.168.1.2:80"\n    reusePort: true\n'})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-yaml",metastring:'tab="Helm Chart Values"',children:"additionalArguments:\n  - --entryPoints.web.reusePort=true\n  - --entryPoints.privateWeb.address=192.168.1.2:80\n  - --entryPoints.privateWeb.reusePort=true\n"})}),"\n",(0,r.jsx)(t.h4,{id:"supported-platforms",children:"Supported platforms"}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"reusePort"})," option currently works only on Linux, FreeBSD, OpenBSD and Darwin.\nIt will be ignored on other platforms."]}),"\n",(0,r.jsxs)(t.p,{children:["There is a known bug in the Linux kernel that may cause unintended TCP connection\nfailures when using the ",(0,r.jsx)(t.code,{children:"reusePort"})," option. For more details, see ",(0,r.jsx)(t.a,{href:"https://lwn.net/Articles/853637/",children:"here"}),"."]}),"\n",(0,r.jsx)(t.h4,{id:"canary-deployment",children:"Canary deployment"}),"\n",(0,r.jsxs)(t.p,{children:["Use the ",(0,r.jsx)(t.code,{children:"reusePort"})," option with the other option ",(0,r.jsx)(t.code,{children:"transport.lifeCycle.gracetimeout"}),"\nto do\ncanary deployments against Mesh itself. Like upgrading Mesh version\nor reloading the static configuration without any service downtime."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>o});var s=n(6540);const r={},i=s.createContext(r);function l(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);