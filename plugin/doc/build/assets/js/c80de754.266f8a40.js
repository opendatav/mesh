"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[3309],{7371:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"reference/routing-configuration/kubernetes/crd/tcp/ingressroutetcp","title":"Kubernetes IngressRouteTCP","description":"An IngressRouteTCP is a Mesh CRD is in charge of connecting incoming TCP connections to the Services that can handle them.","source":"@site/docs/reference/routing-configuration/kubernetes/crd/tcp/ingressroutetcp.md","sourceDirName":"reference/routing-configuration/kubernetes/crd/tcp","slug":"/reference/routing-configuration/kubernetes/crd/tcp/ingressroutetcp","permalink":"/doc/docs/reference/routing-configuration/kubernetes/crd/tcp/ingressroutetcp","draft":false,"unlisted":false,"editUrl":"https://github.com/opendatav/mesh/tree/main/packages/create-docusaurus/templates/shared/docs/reference/routing-configuration/kubernetes/crd/tcp/ingressroutetcp.md","tags":[],"version":"current","frontMatter":{"title":"Kubernetes IngressRouteTCP","description":"An IngressRouteTCP is a Mesh CRD is in charge of connecting incoming TCP connections to the Services that can handle them."},"sidebar":"tutorialSidebar","previous":{"title":"Mesh Kubernetes Services Documentation","permalink":"/doc/docs/reference/routing-configuration/kubernetes/crd/http/traefikservice"},"next":{"title":"Kubernetes MiddlewareTCP","permalink":"/doc/docs/reference/routing-configuration/kubernetes/crd/tcp/middlewaretcp"}}');var t=r(4848),i=r(8453);const c={title:"Kubernetes IngressRouteTCP",description:"An IngressRouteTCP is a Mesh CRD is in charge of connecting incoming TCP connections to the Services that can handle them."},o=void 0,d={},a=[{value:"Configuration Example",id:"configuration-example",level:2},{value:"Configuration Options",id:"configuration-options",level:2},{value:"ExternalName Service",id:"externalname-service",level:3},{value:"NativeLB",id:"nativelb",level:3}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"IngressRouteTCP"})," is the CRD implementation of a ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/routing-configuration/tcp/router/rules-and-priority",children:"Mesh TCP router"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Before creating ",(0,t.jsx)(n.code,{children:"IngressRouteTCP"})," objects, you need to apply the ",(0,t.jsx)(n.a,{href:"https://doc.Mesh.io/Mesh/reference/dynamic-configuration/kubernetes-crd/#definitions",children:"Mesh Kubernetes CRDs"})," to your Kubernetes cluster."]}),"\n",(0,t.jsxs)(n.p,{children:["This registers the ",(0,t.jsx)(n.code,{children:"IngressRouteTCP"})," kind and other mesh-specific resources."]}),"\n",(0,t.jsx)(n.p,{children:'!!! note "General"\nIf both HTTP routers and TCP routers are connected to the same EntryPoint, the TCP routers will apply before the HTTP routers. If no matching route is found for the TCP routers, then the HTTP routers will take over.'}),"\n",(0,t.jsx)(n.h2,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,t.jsxs)(n.p,{children:["You can declare an ",(0,t.jsx)(n.code,{children:"IngressRouteTCP"})," as detailed below:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRoute"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRouteTCP\nmetadata:\n  name: ingressroutetcpfoo\n  namespace: apps\n\nspec:\n  entryPoints:\n    - footcp\n  routes:\n  - match: HostSNI(`*`)\n    priority: 10\n    middlewares:\n    - name: middleware1\n      namespace: default\n    services:\n    - name: foo\n      port: 8080\n      weight: 10\n      proxyProtocol:\n        version: 1\n      serversTransport: transport\n      nativeLB: true\n      nodePortLB: true\n      tls: false\n\n  tls:\n    secretName: supersecret\n    options:\n      name: opt\n      namespace: default\n    certResolver: foo\n    domains:\n    - main: example.net\n      sans:                       \n      - a.example.net\n      - b.example.net\n    passthrough: false\n"})}),"\n",(0,t.jsx)(n.h2,{id:"configuration-options",children:"Configuration Options"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Field"}),(0,t.jsx)(n.th,{children:"Description"}),(0,t.jsx)(n.th,{children:"Default"}),(0,t.jsx)(n.th,{children:"Required"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"entryPoints"})}),(0,t.jsx)(n.td,{children:"List of entrypoints names."}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes"})}),(0,t.jsx)(n.td,{children:"List of routes."}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:"Yes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].match"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/routing-configuration/tcp/router/rules-and-priority#rules",children:"rule"})," of the underlying router."]}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:"Yes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].priority"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/routing-configuration/tcp/router/rules-and-priority#priority",children:"priority"})," to disambiguate rules of the same length, for route matching."]}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].middlewares[n].name"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/routing-configuration/kubernetes/crd/tcp/middlewaretcp",children:"MiddlewareTCP"})," name."]}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:"Yes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].middlewares[n].namespace"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/routing-configuration/kubernetes/crd/tcp/middlewaretcp",children:"MiddlewareTCP"})," namespace."]}),(0,t.jsx)(n.td,{children:'""'}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].services"})}),(0,t.jsxs)(n.td,{children:["List of ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," definitions."]}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].services[n].name"})}),(0,t.jsxs)(n.td,{children:["Defines the name of a ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"}),"."]}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:"Yes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].services[n].port"})}),(0,t.jsxs)(n.td,{children:["Defines the port of a ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"}),". This can be a reference to a named port."]}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:"Yes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].services[n].weight"})}),(0,t.jsx)(n.td,{children:"Defines the weight to apply to the server load balancing."}),(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].services[n].proxyProtocol"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/install-configuration/entrypoints#proxyprotocol-and-load-balancers",children:"PROXY protocol"})," configuration."]}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].services[n].proxyProtocol.version"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/install-configuration/entrypoints#proxyprotocol-and-load-balancers",children:"PROXY protocol"})," version."]}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].services[n].serversTransport"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/routing-configuration/kubernetes/crd/tcp/serverstransporttcp",children:"ServersTransportTCP"}),".",(0,t.jsx)("br",{}),"The ",(0,t.jsx)(n.code,{children:"ServersTransport"})," namespace is assumed to be the ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/",children:"Kubernetes service"})," namespace."]}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].services[n].nativeLB"})}),(0,t.jsxs)(n.td,{children:["Controls, when creating the load-balancer, whether the LB's children are directly the pods IPs or if the only child is the Kubernetes Service clusterIP. See ",(0,t.jsx)(n.a,{href:"#nativelb",children:"here"})," for more information."]}),(0,t.jsx)(n.td,{children:"false"}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"routes[n].services[n].nodePortLB"})}),(0,t.jsxs)(n.td,{children:["Controls, when creating the load-balancer, whether the LB's children are directly the nodes internal IPs using the nodePort when the service type is ",(0,t.jsx)(n.code,{children:"NodePort"}),". It allows services to be reachable when Mesh runs externally from the Kubernetes cluster but within the same network of the nodes."]}),(0,t.jsx)(n.td,{children:"false"}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls"})}),(0,t.jsxs)(n.td,{children:["Defines ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/install-configuration/tls/certificate-resolvers/overview",children:"TLS"})," certificate configuration."]}),(0,t.jsx)(n.td,{}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.secretName"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/configuration/secret/",children:"secret"})," name used to store the certificate (in the ",(0,t.jsx)(n.code,{children:"IngressRoute"})," namespace)."]}),(0,t.jsx)(n.td,{children:'""'}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.options"})}),(0,t.jsxs)(n.td,{children:["Defines the reference to a ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/routing-configuration/kubernetes/crd/http/tlsoption",children:"TLSOption"}),"."]}),(0,t.jsx)(n.td,{children:'""'}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.options.name"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/routing-configuration/kubernetes/crd/http/tlsoption",children:"TLSOption"})," name."]}),(0,t.jsx)(n.td,{children:'""'}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.options.namespace"})}),(0,t.jsxs)(n.td,{children:["Defines the ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/routing-configuration/kubernetes/crd/http/tlsoption",children:"TLSOption"})," namespace."]}),(0,t.jsx)(n.td,{children:'""'}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.certResolver"})}),(0,t.jsxs)(n.td,{children:["Defines the reference to a ",(0,t.jsx)(n.a,{href:"/doc/docs/reference/install-configuration/tls/certificate-resolvers/overview",children:"CertResolver"}),"."]}),(0,t.jsx)(n.td,{children:'""'}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.domains"})}),(0,t.jsx)(n.td,{children:"List of domains."}),(0,t.jsx)(n.td,{children:'""'}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.domains[n].main"})}),(0,t.jsx)(n.td,{children:"Defines the main domain name."}),(0,t.jsx)(n.td,{children:'""'}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.domains[n].sans"})}),(0,t.jsx)(n.td,{children:"List of SANs (alternative domains)."}),(0,t.jsx)(n.td,{children:'""'}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"tls.passthrough"})}),(0,t.jsxs)(n.td,{children:["If ",(0,t.jsx)(n.code,{children:"true"}),", delegates the TLS termination to the backend."]}),(0,t.jsx)(n.td,{children:"false"}),(0,t.jsx)(n.td,{children:"No"})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"externalname-service",children:"ExternalName Service"}),"\n",(0,t.jsxs)(n.p,{children:["Mesh connect to a backend with a domain and a port. However, Kubernetes ",(0,t.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/service/#externalname",children:"ExternalName Service"})," can be defined without any port. Accordingly, Mesh supports defining a port in two ways:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["only on ",(0,t.jsx)(n.code,{children:"IngressRouteTCP"})," service"]}),"\n",(0,t.jsxs)(n.li,{children:["on both sides, you'll be warned if the ports don't match, and the ",(0,t.jsx)(n.code,{children:"IngressRouteTCP"})," service port is used"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Thus, in case of two sides port definition, Mesh expects a match between ports."}),"\n",(0,t.jsx)(n.p,{children:'=== "Ports defined on Resource"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRouteTCP"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRouteTCP\nmetadata:\n  name: test.route\n  namespace: apps\n\nspec:\n  entryPoints:\n    - foo\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: external-svc\n      port: 80\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Service ExternalName"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: apps\n\nspec:\n  externalName: external.domain\n  type: ExternalName\n"})}),"\n",(0,t.jsx)(n.p,{children:'=== "Port defined on the Service"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRouteTCP"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRouteTCP\nmetadata:\n  name: test.route\n  namespace: apps\n\nspec:\n  entryPoints:\n    - foo\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: external-svc\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Service ExternalName"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: apps\n\nspec:\n  externalName: external.domain\n  type: ExternalName\n  ports:\n    - port: 80\n"})}),"\n",(0,t.jsx)(n.p,{children:'=== "Port defined on both sides"'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRouteTCP"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRouteTCP\nmetadata:\n  name: test.route\n  namespace: apps\n\nspec:\n  entryPoints:\n    - foo\n  routes:\n  - match: Host(`example.net`)\n    kind: Rule\n    services:\n    - name: external-svc\n      port: 80\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Service ExternalName"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: external-svc\n  namespace: apps\n\nspec:\n  externalName: external.domain\n  type: ExternalName\n  ports:\n    - port: 80\n"})}),"\n",(0,t.jsx)(n.h3,{id:"nativelb",children:"NativeLB"}),"\n",(0,t.jsxs)(n.p,{children:["To avoid creating the server load-balancer with the pods IPs and use Kubernetes Service ",(0,t.jsx)(n.code,{children:"clusterIP"})," directly, one should set the ",(0,t.jsx)(n.code,{children:"NativeLB"})," option to true. By default, ",(0,t.jsx)(n.code,{children:"NativeLB"})," is false."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="IngressRouteTCP"',children:"apiVersion: Mesh.io/v1alpha1\nkind: IngressRouteTCP\nmetadata:\n  name: test.route\n  namespace: default\nspec:\n  entryPoints:\n    - foo\n  routes:\n  - match: HostSNI(`*`)\n    services:\n    - name: svc\n      port: 80\n      # Here, nativeLB instructs to build the servers load balancer with the Kubernetes Service clusterIP only.\n      nativeLB: true\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",metastring:'tab="Service"',children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: svc\n  namespace: default\nspec:\n  type: ClusterIP\n  ...\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>c,x:()=>o});var s=r(6540);const t={},i=s.createContext(t);function c(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);