"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[3596],{2442:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>i,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"reference/routing-configuration/udp/router/rules-priority","title":"Mesh UDP Routers Rules & Priority Documentation","description":"In Mesh Proxy, a router is in charge of connecting incoming requests to the Services that can handle them. Read the technical documentation.","source":"@site/docs/reference/routing-configuration/udp/router/rules-priority.md","sourceDirName":"reference/routing-configuration/udp/router","slug":"/reference/routing-configuration/udp/router/rules-priority","permalink":"/doc/docs/reference/routing-configuration/udp/router/rules-priority","draft":false,"unlisted":false,"editUrl":"https://github.com/opendatav/mesh/tree/main/packages/create-docusaurus/templates/shared/docs/reference/routing-configuration/udp/router/rules-priority.md","tags":[],"version":"current","frontMatter":{"title":"Mesh UDP Routers Rules & Priority Documentation","description":"In Mesh Proxy, a router is in charge of connecting incoming requests to the Services that can handle them. Read the technical documentation."},"sidebar":"tutorialSidebar","previous":{"title":"Mesh TLS Documentation","permalink":"/doc/docs/reference/routing-configuration/tcp/tls"},"next":{"title":"Mesh UDP Services Documentation","permalink":"/doc/docs/reference/routing-configuration/udp/service"}}');var o=t(4848),s=t(8453);const i={title:"Mesh UDP Routers Rules & Priority Documentation",description:"In Mesh Proxy, a router is in charge of connecting incoming requests to the Services that can handle them. Read the technical documentation."},a=void 0,c={},u=[{value:"Sessions and timeout",id:"sessions-and-timeout",level:2},{value:"EntryPoints",id:"entrypoints",level:2},{value:"Configuration Example",id:"configuration-example",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["A router is in charge of connecting incoming requests to the services that can handle them.\nIn the process, routers may use pieces of ",(0,o.jsx)(n.a,{href:"/doc/docs/reference/routing-configuration/http/middlewares/overview",children:"middleware"})," to update the request,\nor act before forwarding the request to the service."]}),"\n",(0,o.jsxs)(n.p,{children:["Similarly to TCP, as UDP is the transport layer, there is no concept of a request,\nso there is no notion of an URL path prefix to match an incoming UDP packet with.\nFurthermore, as there is no good TLS support at the moment for multiple hosts,\nthere is no Host SNI notion to match against either.\nTherefore, there is no criterion that could be used as a rule to match incoming packets in order to route them.\nSo UDP ",(0,o.jsx)(n.em,{children:"routers"})," at this time are pretty much only load-balancers in one form or another."]}),"\n",(0,o.jsx)(n.p,{children:"!!! tip\nUDP routers can only target UDP services (and not HTTP or TCP services)."}),"\n",(0,o.jsx)(n.h2,{id:"sessions-and-timeout",children:"Sessions and timeout"}),"\n",(0,o.jsxs)(n.p,{children:["Even though UDP is connectionless (and because of that),\nthe implementation of an UDP router in Mesh relies on what we (and a couple of other implementations) call a ",(0,o.jsx)(n.code,{children:"session"}),".\nIt means that some state is kept about an ongoing communication between a client and a backend,\nnotably so that the proxy knows where to forward a response packet from a backend."]}),"\n",(0,o.jsxs)(n.p,{children:["As expected, a ",(0,o.jsx)(n.code,{children:"timeout"})," is associated to each of these sessions,\nso that they get cleaned out if they go through a period of inactivity longer than a given duration."]}),"\n",(0,o.jsxs)(n.p,{children:["Timeout can be configured using the ",(0,o.jsx)(n.code,{children:"entryPoints.name.udp.timeout"})," option as described under ",(0,o.jsx)(n.a,{href:"/doc/docs/reference/install-configuration/entrypoints",children:"EntryPoints"})]}),"\n",(0,o.jsx)(n.h2,{id:"entrypoints",children:"EntryPoints"}),"\n",(0,o.jsxs)(n.p,{children:["If not specified, UDP routers will accept packets from all defined (UDP) EntryPoints. If one wants to limit the router scope to a set of EntryPoints, one should set the ",(0,o.jsx)(n.code,{children:"entryPoints"})," option."]}),"\n",(0,o.jsx)(n.h2,{id:"configuration-example",children:"Configuration Example"}),"\n",(0,o.jsx)(n.p,{children:"Listens to Every Entry Point"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",metastring:'tab="Structured (YAML)"',children:'udp:\n  routers:\n    Router-1:\n      # By default, routers listen to all UDP entrypoints\n      # i.e. "other", and "streaming".\n      service: "service-1"\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-toml",metastring:'tab="Structured (TOML)"',children:'[udp.routers]\n  [udp.routers.Router-1]\n    # By default, routers listen to all UDP entrypoints,\n    # i.e. "other", and "streaming".\n    service = "service-1"\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",metastring:'tab="Labels"',children:'labels:\n  - "Mesh.udp.routers.Router-1.service=service-1"\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",metastring:'tab="Tags"',children:'{\n  //...\n  "Tags": [\n    "Mesh.udp.routers.Router-1.service=service-1"\n  ]\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Listens to Specific EntryPoints"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",metastring:'tab="Structured (YAML)"',children:'udp:\n  routers:\n    Router-1:\n      # does not listen on "other" entry point\n      entryPoints:\n        - "streaming"\n      service: "service-1"\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-toml",metastring:'tab="Structured (TOML)"',children:'[udp.routers]\n  [udp.routers.Router-1]\n    # does not listen on "other" entry point\n    entryPoints = ["streaming"]\n    service = "service-1"\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",metastring:'tab="Labels"',children:'labels:\n  - "Mesh.udp.routers.Router-1.entryPoints=streaming"\n  - "Mesh.udp.routers.Router-1.service=service-1"\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-json",metastring:'tab="Tags"',children:'{\n  //...\n  "Tags": [\n    "Mesh.udp.routers.Router-1.entryPoints=streaming",\n    "Mesh.udp.routers.Router-1.service=service-1"\n  ]\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:'!!! info "Service"'}),"\n",(0,o.jsxs)(n.p,{children:["There must be one (and only one) UDP ",(0,o.jsx)(n.a,{href:"/doc/docs/reference/routing-configuration/udp/service",children:"service"})," referenced per UDP router.\nServices are the target for the router."]})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const o={},s=r.createContext(o);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);